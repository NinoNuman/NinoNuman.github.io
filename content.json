{"meta":{"title":"Nino Neumann","subtitle":"所念皆如意，未来皆可期","description":"a cs student","author":"Nino Neumann","url":"https://ninoneumann.cn","root":"/"},"pages":[{"title":"分类","date":"2018-01-04T16:00:00.000Z","updated":"2022-04-14T07:50:04.212Z","comments":true,"path":"categories/index.html","permalink":"https://ninoneumann.cn/categories/index.html","excerpt":"","text":""},{"title":"友链以及网页推荐","date":"2022-04-14T07:46:35.000Z","updated":"2022-04-14T07:47:38.817Z","comments":true,"path":"link/index.html","permalink":"https://ninoneumann.cn/link/index.html","excerpt":"","text":""},{"title":"标籤","date":"2018-01-04T16:00:00.000Z","updated":"2022-04-14T07:50:20.152Z","comments":true,"path":"tags/index.html","permalink":"https://ninoneumann.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Anki安装-美化-使用","slug":"Anki安装-美化-使用","date":"2022-05-08T01:33:18.000Z","updated":"2022-05-08T02:26:01.038Z","comments":true,"path":"2022/05/08/Anki安装-美化-使用/","link":"","permalink":"https://ninoneumann.cn/2022/05/08/Anki%E5%AE%89%E8%A3%85-%E7%BE%8E%E5%8C%96-%E4%BD%BF%E7%94%A8/","excerpt":"","text":"更新时间线 2022-5-8anki的初见、上手、初级的“美化” Anki安装-美化-使用 Anki的介绍以及本博客引用的相关文章 open Anki是什么，该怎么用？ - 知乎 (zhihu.com)Anki卡片不漂亮？简单一个方法教你做出各种漂亮的笔记类型_哔哩哔哩_bilibiliAnki 超强插件推荐 - 知乎 (zhihu.com) Anki介绍 一款用来记忆单词或者其他的事情的一个软件，相较于墨墨背单词之类的app，它的优点就是强大的灵活性吧，毕竟可以自定义。 Anki安装 没啥好说的到官网download稳定版 Anki - powerful, intelligent flashcards (ankiweb.net) 可能得开梯子。 Anki美化 关于美化的话先套一个模板吧，其实自己学号css之后可以完全自定义，空间还是挺大的。 Anki主页配置【待完成】 在介绍anki插件的一个知乎上面看到了优化主界面的一个插件就想去搞一下，但是我发现他说的很模糊，所以自己摸索了一下如何安装这些配置【也就是css属性如何添加上去。】 使用评测","categories":[{"name":"不正经做事儿系列","slug":"不正经做事儿系列","permalink":"https://ninoneumann.cn/categories/%E4%B8%8D%E6%AD%A3%E7%BB%8F%E5%81%9A%E4%BA%8B%E5%84%BF%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Anki","slug":"Anki","permalink":"https://ninoneumann.cn/tags/Anki/"},{"name":"英语","slug":"英语","permalink":"https://ninoneumann.cn/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"英语阅读-学习","slug":"英语阅读-学习","date":"2022-05-08T00:58:02.000Z","updated":"2022-05-08T09:15:46.418Z","comments":true,"path":"2022/05/08/英语阅读-学习/","link":"","permalink":"https://ninoneumann.cn/2022/05/08/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB-%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"5.8 长难句翻译1： The decision of the New York Philharmonic to hire Alan Gilbert as its next music director has been the talk of the classical-music world ever since the announcement of his appointment in 2009. 单词： appointment: n 任命 、 约定 句子2： For the most part, the response has been favorable, to say the least. “Hooray! At last!” wrote Anthony Tommasini, a sober-sided classical-music critic. 这个句子中存在一些不是很熟悉的单词 所以看上去很吃力 单词： sober-sided: 句子34： One of the reasons why the appointment came as such a surprise, however, is that Gilbert is comparatively little known. Even Tommasini, who had advocated Gilbert’s appointment in the Times, calls him “an unpretentious musician with no air of the formidable conductor about him.” 第四句的主要难点也是在于生词 单词： unpretentious: pretentious: formidable: ​ with no air of formidable in the Times： ​ Times： 时代周刊 句子5： As a description of the next music director of an orchestra that has hitherto been led by musicians like Gustav Mahler and Pierre Boulez, that seems likely to have struck at least some Times readers as faint praise 翻译： （自己的） 作为一个一直以来由Gustav Mahler 和 Pierre Boulez这样的音乐家领导的一个乐团的下一任音乐指挥的描述，这样的描述至少被泰晤士报的读者们认为是苍白的夸奖。 句子6： For my part, I have no idea whether Gilbert is a great conductor or even a good one. 翻译： 对于我而言，我不知道吉尔伯特是否是一位伟大的指挥家，我甚至不知道他是否是一位好的指挥家。 这里的英语表达中的并列关系引起了省略 所以用中文思维读起来很怪。","categories":[{"name":"英语二","slug":"英语二","permalink":"https://ninoneumann.cn/categories/%E8%8B%B1%E8%AF%AD%E4%BA%8C/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"英语","slug":"英语","permalink":"https://ninoneumann.cn/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"如何准备考研英语","slug":"如何准备考研英语","date":"2022-05-07T02:31:31.000Z","updated":"2022-05-08T00:46:31.889Z","comments":true,"path":"2022/05/07/如何准备考研英语/","link":"","permalink":"https://ninoneumann.cn/2022/05/07/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD/","excerpt":"","text":"如何准备考研英语 open (3 封私信 / 80 条消息) 如何准备考研英语？ - 知乎 (zhihu.com) 单词要背好、长难句要掌握好！ 单词 现在在用的是 不背单词 APP 准备入手 扇贝APP 用来记忆的软件 ANKI 找个时间了解一下。 长难句 推荐中推荐了何凯文老师的 完型 做真题 但是不要上来就做要考的那一门的真题，也就是 如果考英语一那就做英语二的真题(反之)。 完型主要考查的是对词汇的掌握。一是文章大意的理解，二是近义词的辨析，三是词汇的确切意思。 一定要先读懂全文第一句话 推荐视频的话，我依旧是推荐商志老师的暑期强化课程中的完型课程。一定要用可加速播放的视频播放器，不然一篇完型讲完时间已经过去了几个小时。 阅读 张剑 黄皮书 翻译 作文","categories":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"}]},{"title":"编码规范","slug":"编码规范","date":"2022-05-05T03:10:43.000Z","updated":"2022-05-05T03:10:43.840Z","comments":true,"path":"2022/05/05/编码规范/","link":"","permalink":"https://ninoneumann.cn/2022/05/05/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"编码规范 编码规范是一个程序员的基本准则需要好好掌握 概述 一个好的可读性强的编码风格对日后程序的维护拓展有巨大的作用 节省开发时间减少无用的二次编译 增加程序的可读性 便于维护 不要采用RAF策略 RAF run and fix 在日后的编码代码吗过程中请先思考完整再去编写代码。 编写准则 一行只写一条语句。 对于变量声明也是一样 一行只声明一个变量 可以将有关系的变量靠拢。 使用空行分割： 区分声明语句和执行语句 执行语句中分段落 switch语句中的case 也最好加入空行区分 对于子函数的定义部分最好在他们之间用三行空行的间隔隔开（用更多的空行隔开） 对于双目运算符在左右最好加入一个空格 对于单目运算符将运算符和操作数紧贴。 在变量初始化的时候最好能对齐初始化的参数。 关于大括号： 可以适当减少冗余大括号。 关于缩进： 注意代码块之间的缩进对齐 关于注释： 需要对不同种类的注释进行不一样的样式声明。（jetbrain 插件中有一键插入注释的吗）要不自己写一个pycharm的插件 生成不同类型的注释。 在大括号哦闭合的地方插入其对应的大括号的标识 明确嵌套结构 变量命名： 匈牙利表示法 存储类型_数据类型_数据名称 请不要使用下划线开头命名变量 更不要使用两个下划线命名。 函数命名： 最好能表示出函数所代表的意义。 单词首字母大写。 函数中标识符的命名一定也要有意义。 适当添加后缀 用下划线隔开 宏定义： 统统大写！ 运算符号： 使用括号表示运算优先级 将指针符号紧贴标识符号 while循环中的表达 切记不要使用隐式的非0测试 可移植程序 不要使用绝对路径","categories":[],"tags":[{"name":"编码规范","slug":"编码规范","permalink":"https://ninoneumann.cn/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"算法笔记","slug":"算法笔记","date":"2022-04-28T06:27:44.000Z","updated":"2022-05-02T07:37:00.469Z","comments":true,"path":"2022/04/28/算法笔记/","link":"","permalink":"https://ninoneumann.cn/2022/04/28/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"更新时间线 2022-4-29添加一点踩坑记录c++中scanf 和 cin2022-4-291、算法笔记学习记录 第四章2022-4-281、算法笔记学习记录 第三章 算法笔记 warning: 选择测试和提交的语言一定要多多注意 我这里使用clang++ 是没问题的 但是用g++可能会出现问题 第三章： 进制转换： 我自己觉得我的弱点在于进制转换，蓝桥杯也是，进制转换的相关题目没做出来 任意的十进制 int -&gt; 2进制 应该可以使用位运算来解决 对于十进制转换为任意进制： 取余逆序排列 最终的结果可以存放到一个数组中或者一个string里 这样就可以构成一个 string-&gt; string/nums[] 小数进制转换可以是 int-&gt; nums[] P进制转换为十进制： 可以被int读入的 较小的 p进制数 （默认p&lt;10） int 转换为 p进制 除基取余法 例题： 题目详情 - 1015 Reversible Primes (pintia.cn) 这一题的主要问题在于对一个数是否是素数的判断上： 参考柳神的算法 1234567bool isprime(int x)&#123; if(x&lt;=1)return false; // 如果是一个1以下的数 就不是素数 for(int i = 2;i&lt;=sqrt(x*1.0);++i)&#123; if(x%i==0)return false; &#125; return true;&#125; 第四章 排序算法 sort 直接调用algorithm库里面的算法 STL 模板库 vector 用于作为邻接表 set set只能通过iterator访问。 自动排序 （对 int double 等基础数据类型 struct 的话重写&lt;运算符应该也可以） 踩坑记录 c++中的scanf() 和 cin scanf() 读入字符串 结论： scanf读入字符串 需要先给string分配好地址 读入的一串字符串中如果含有空格怎么办？【string类的输入】 来源：C++ Primer Plus 书 三种输入 1234string str;cin&gt;&gt;str;getline(cin,str);getline(cstr,&quot;:&quot;); //将 &quot;:&quot;作为边界符 自动设置string的大小 速度可能会慢","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/categories/PAT/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://ninoneumann.cn/tags/algorithm/"},{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/tags/PAT/"}]},{"title":"计算机网络第三章","slug":"计算机网络第三章","date":"2022-04-28T03:25:03.000Z","updated":"2022-05-05T08:55:10.661Z","comments":true,"path":"2022/04/28/计算机网络第三章/","link":"","permalink":"https://ninoneumann.cn/2022/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0/","excerpt":"","text":"更新时间线 2022-5-5哭了 我的进度拉下了好多 lag整理+一些概念的添加2022-4-28整理+一些概念的添加发现老师好像在MAC成帧的方法中只讲了一种(所以我拓展了一下 待完工)完善LLC部分的知识2022-4-27整理计算机网络第三章的一些知识 内容参考 (130条消息) 计算机网络的数据链路层_Clichong的博客-CSDN博客_pwm调速(130条消息) 数据链路层的成帧方法_Wzning0421的博客-CSDN博客_成帧的方法很全面！强烈安利：(130条消息) 计算机网络知识汇总（超详细整理）_Dreamchaser追梦的博客-CSDN博客_计算机网络基础知识大全 [TOC] 计算机网络第三章 数据链路层 Data Link Layer 第三章的前半部分主要就是从解决三个问题入手： framing (成帧) flow control error control 数据链路层的概念 什么是数据链路层 有区别于物理层 数据链路层建立的是逻辑链路 数据链路层存在的意义 cogs: The data link layer is responsible for efficient and reliable communication across a physical link.数据链路层在物理层 连接上提供一条高效 可靠的逻辑连接，为网络层提供服务。 The data link layer provides services to the network layer 物理链路和逻辑链路的区别 cogs: 这里是介绍的一个部分可以略过去 就是单纯滴为加强理解而写的一部分 物理链路： 是指在物理层设备（包括传输介质、物理接口和收发器等）和相应物理层通信规程作用下形成的物理线路，是永久存在的，且是不可删除的（除非物理拆除） 数据链路： 是通信双方在需要进行数据通信时，在数据链路层设备和相应的通信规程作用下建立的逻辑链路，可以是永远存在的（如局域网中的以太网链路），也可以不是永久存在的（如广域网中的链路），是否永久存在要视具体的数据链路层服务类型而定。 数据链路层存在的目的 在原始的、有差错的物理传输线路的基础上，采取差错检测，差错控制和流量控制等方法，将有差错的物理线路改进成逻辑上的无差错的数据链路，以便向他的上一层网络层提供高质量的服务。 具体而言，数据链路层中与传输介质访问无关的问题都集中在 LLC 子层来解决，为网络层提供服务。其主要功能包括逻辑链路的建立和释放、提供与网络层的接口（也就是前面说到的 SAP）、数据传输差错控制、给数据帧加上传输序列号等。 数据链路层存在的必要性 一是数据链路层可以屏蔽物理层中介与传输介质的不同，以及通信，规程协议的不同，从逻辑上正从逻辑意义上构建一条性能稳定，不受传输介质类型影响的人物及数据传输通道。 二是因为物理层数据是一位一位单独传输的，传输效率低，而且容易出现数据传输差错，通过数据链路层把数据进行封装成以帧为单位进行传输，可以提高传输效率，而且还能做数据传输差错控制。 数据链路层的结构 LLC (Logic Link Control) 逻辑链路控制 LLC子层的最基本功能，就是负责数据链路层中的逻辑链路(逻辑链路就是物理层信道中的物理链路，在通过LLC协议作用后形成的虚拟电路)。包括逻辑链路的建立和释放，控制信号交换，数据流量控制，解释上层通信协议传来的命令并生产响应，以及克服数据在传输的过程当中发生的种种问题。如数据发生错误、重复收到相同的数据、接收数据顺序与传送的顺序不一致等。在LLC子层方面，IEEE 802系列中只制定了一种标准——IEEE 802.2。 MAC (Medium Access Control) 介质访问控制 控制不同用户数据传输中对物理层传输介质的访问，包括数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，帧的差错控制，以及介质访问冲突控制等。 数据链路层提供的服务 Unacknowledged connectionless 无确认 无连接 服务 接收方不对收到的帧进行确认 也不会对frame进行接受确认 适用场景：误码率低的可靠信道；实时通信； 网络实例：以太网 Acknowledged connectionless 有确认 无连接 服务 每一帧都得到单独的确认 适用场景：不可靠的信道（无线信道） 网络实例：802.11 Acknowledged connection-oriented 有确认 有连接 服务 适用场景：长延迟的不可靠信道 数据链路层的主要功能及其原理 DLL(Data Link Layer) must provide 数据链路层需要解决的几个问题 : frame synchronization flow control error control addressing link management 基本功能 透明 + 可靠 透明”是指要使在数据链路层上所传输的数据在内容、格式及编码上都没有限制，也就是要使一些本来用于特殊用途的控制字符（具体有哪些控制字符将在本章后面介绍）也能像正常的数据一样传输，使接收端不要误认为这些字符为控制字符； 可靠的传输使数据从发送端无差错地在数据链路上传输到目的接收端。 LLC 功能 流量控制 The main problem we have to deal with here is how to prevent the sender from flooding the receiver with data faster than the latter is able to process them. 流量控制协议Flow control protocols Stop and Wait Protocols 停等协议 ， 也是 ARQ (Automatic Repeat reQuest) Protocols in which the sender sends one frame and then waits for an acknowledgement before proceeding are called stop-and-wait. 停等协议面临的几个问题 如果发送方一直接收到NAK怎么办？ reciver 超时没法来ACK怎么办？ 数据包在传输的时候丢失怎么办？ 丢失后重传造成duplicated frame怎么解决？ 数据包传输中出错怎么办？ 如果发送方一直接收到NAK怎么办？ 设置一个最大的重传次数 如果重传次数超过 则向上层发送出错报告。 reciver 超时没法来ACK怎么办？ 设置一个超时计时器 如果超时没有接收到ACK 则retransmits the frame。 数据包在传输的时候丢失怎么办？ 重传！ 丢失后重传造成duplicated frame怎么解决？ 注意这里的英文表达 : introduce Retransmissions may introduce duplicate frames received by B 给传输的frame添加一个序列号 sequence numbers 关于ARQ协议 的Utilization 的计算 （结论 ARQ协议的Utilization很低） 胡烈ACK的传输时延 为了提升传输的效率 这里引出了滑动窗口协议 滑动窗口协议 滑动窗口协议中： 发送者能够一次性发送n个framme而不需要等待ack 每nframes中都包含一个unique sequence number 发送者分配unique sequence number 接受者也维护一个他准备接受的sequence number 后退n帧协议 如果在滑动窗口协议中某一帧的frame出现丢失怎办 The sender will then retransmit the damage frame and all the frames that follow it sender将会从丢失的frame处重新传输 （包括lost-frame之后的frames） 实现后退n帧协议只需要将reciver的sliding windows大小设置为1这样如果出现丢frame的情况reciver就会remain same frame. 缺陷：Go back n 会浪费掉很多的连接资源（由于不断的重传） 选择性重传【这个暂时先略过】 GBN协议的相关例题： GBN协议的一些总结： 如果想要计算信道利用率最大得设置的窗口数据帧数量的话就使用 sender从发送data到接收到ack的时间/sender发送一个frame的时间 MAC 功能 成帧 frame sychronization 【帧定界】:接收方必须能从物理层发送过来的二进制比特流中明确的区分出一个frame的开始和结束 关键: 选择何种的定界符？如果定界符出现在frame中该如何处理 成帧的方法 带比特填充的定界符法 （Bit Stuffing位填充） 下面介绍两种（老师可能只提了一嘴的）方法 字符计数法 字符计数法 用一个帧的第一字节来说明帧的总长度（总长度包含这个帧头） 如果出现问题： 看这张图，白色为帧头，指明了长度，比如第一帧长度为5，后面就跟了4个字节，第二帧的长度为5，后面也跟了4字节，之后是两个8字节长度的，所以各自跟了7字节的正文部分。但是很显然，如果头这一个字节出了问题，影响的就不仅仅是这一帧了，其他的都会出问题。比如： 字符填充的首尾界定法 这个方法就是将比特填充换成了某一个特定字符 下面介绍一种物理层的定界方法：物理层编码违例法 物理层编码违例 核心思想：选择的定界符不会在数据部分出现 该法在物理层采用特定的比特编码方法时采用。例如，曼彻斯特编码方法，是将数据比特“1”编码成“高—低”电平对，将数据比特“0”编码成“低—高”电平对。而“高—高”电平对和“低—低”电平对在数据比特中是违法的。可以借用这些违法编码序列来界定帧的起始与终止。局域网IEEE 802标准中就采用了这种方法。违法编码法不需要任何填充技术，便能实现数据的透明性，但它只适于采用冗余编码的特殊编码环境。 差错控制 （校验+纠错） 奇偶校验 【这个简单你懂的】 校验和(Checksum) 【】 (134条消息) 一文读懂网络报问中的检验和（checksum）—— 原理+举例+代码_Liu Zhian的博客-CSDN博客_检验和 生成checksum过程： 待检验部分从头开始，每16比特进行一次加法计算（如果最后有8位剩余，最后加上这8位），这样最终计算出来的和进行一次反码运算，就是检验和。 检验过程： 和生成过程一样如果最后的结果是全为1的话那么表示没有出错 注意：如果求和过程中遇到了任何溢出，都进行回卷（即加回到最低位） 主要用于TCP/IP体系中的网络层和传输层 CRC 循环冗余校验 海明码 DDL 有检错/重传机制 信道分配问题 时分多址接入-TDMA 频分多址接入-FDMA 多路访问协议 随机访问 ALOHA CSMA 载波监听 持续式 非持续式 受控访问 有限竞争 DDL中的DLP（Data Link Protocols）的例子： HDLC- High-Level Data Link Control 高级数据链路控制 PPP Point-to-Point Protocol 一些知识的解释： 曼彻斯特编码 最后叨叨几句 最近真的很迷茫 不知道该学什么，迷茫于学一些现成的东西还是学一些很基础的知识，学现成的快车知识很容易运用到某一些场景中 但是当遇到一些问题的时候又不能发觉其中的根源，所以我得学基础的，但是基础知识又枯燥乏味。","categories":[{"name":"专业课","slug":"专业课","permalink":"https://ninoneumann.cn/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://ninoneumann.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"专业课","slug":"专业课","permalink":"https://ninoneumann.cn/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"计算机网络第二章","slug":"计算机网络第二章","date":"2022-04-27T12:05:51.000Z","updated":"2022-04-27T12:10:33.802Z","comments":true,"path":"2022/04/27/计算机网络第二章/","link":"","permalink":"https://ninoneumann.cn/2022/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"更新时间线 2022-4-27将自己写的有关于物理层的知识搬运到blog上来了报文交换待补充 物理层 参考的笔记 计算机网络笔记(四)——物理层 - 知乎 (zhihu.com) 【计网】物理层详解_白夜行515的博客-CSDN博客 目录： 考研考纲要求 物理层的主要作用 物理层的主要特性 通信基础 资源子网和通信子网 资源子网 通信子网 通信子网的种类 数据通信的基本模型 数据通信基本概念 数据传输的类型 基带传输 [频带传输](#频带（宽带）传输 passband transmission) 数据传输方式 数据传输模式 数据通信方式 数据传输速率与信道带宽 :sparkles:码元 :sparkles:波特率、速率、带宽 :sparkles:数字信号传输限制 :sparkles::exclamation:码间干扰 :sparkles::exclamation:[Nyquist Law 奈奎斯特定律](#Nyquist Law 奈奎斯特定律) :sparkles::exclamation:[Shannon 香农定律](#Shannon 香农定律) 物理层的传输媒体 调制方法 信道复用技术 电路交换 考纲要求 通信基础 传输介质 物理层设备 考试重点： 掌握的概念有:信道、信号、宽带、码元、波特、速率、信源与信宿、编码与调制、电路交换、报文交换与分组交换、数据报与虚电路等基本概念。 物理层的主要作用（理解） 构建物理上的数据通路 透明传输： 网络中的各方不用在意数据通路中的传输介质…… （相关标准以及通信协议的功能；） 数据传输： 数据编码 【不太明白】【为了确保数据比特流能在对应的信道中正常通过，需要对数据编码。不同的传输介质所支持的数据编码类型不一样(如归零码、非归零码、曼彻斯特码、差分曼彻斯特码等】 流量管理：【对在信道上传输的比特流进行管理……】 物理层的主要特性 机械特性： 接口的引脚数目、传输介质的种类…… 电器特性： 传输在数据链路上的信号的特征。【暂时这么理解。】 功能特性：【】电平的含义 规程特性： 通信基础： 资源子网和通信子网 资源子网 存放网络中各种数据资源的; 局域网中：由网络服务器、工作站（个人电脑）、共享的打印机设备……所有存储数据资源的设备 以及与网络传输无关的功能设备组成。 广域网中：所有的主机以及外部设备组成。 通信子网 管理通信的相关设备以及软件。 局域网：网关、网桥、集线器、路由器你、中继器、交换机 广域网：专用的通信处理机。 通信子网的种类 点点通信子网 广播通信子网 数据通信的基本模型 信源、信道、信宿 信源 发送信息 信道 传输信息 信宿 接收信息 数据通信基本概念 信息 数据 信号 信道 数据传输的类型 基带信号 宽带信号 基带传输 将01 信号变换成数字信号发出 经常用于局域网 近距离 基带传输系统 频带（宽带）传输 passband transmission 将基带传出的信号使用分频复用的方式转换为模拟信号 传输出去 需要添加调制解调器。 经常用于广域网 速度更快 传输距离更远。 频带传输系统 数据传输方式 串行传输 并行传输 数据传输模式 字符串同步 解决串行传输中正确识别串行传输流中的数据。 同步传输 异步传输 数据通信方式 单向通信 半双工通信 全双工通信 数据传输速率与信道带宽 波特率 衡量 模拟信号中的数据传输速率 比特率 衡量 数字信号中的数据传输速率 码元： 被传输的数据是二进制的 码元是一段时间内包含的二进制 例如： 12345# 传输比特流：011101001如果使用二进制码元 那么单位时间包含的bit数 就是1如果使用四进制码元 那么上面的比特流 每个单位时间就包含两个bit这个时间内的码元就称为K进制码元 波特率、速率、带宽 速率： 比特率 比特传输速率 b/s 【单位时间内传输的二进制代码的有效比特位 用Rb 表示】 波特率 码元传输速率 Baud ：波特率显示了单位时间内电平变换的频率 【单位时间内载波参数(如频率相位等)变化的次数，单位为B(Baud)，用RB表示。】 比特率和波特率之间的关系：假设：k进制码元一段数据的比特率=v b/s则: 这段数据的波特率=vlog2k Baud比特率和波特率之间的关系：\\\\ 假设：\\\\ k进制码元\\\\ \\quad 一段数据的比特率=v\\,\\,b/s\\\\ \\quad 则:\\,\\,这段数据的波特率=\\frac{v}{log_2k}\\,\\,Baud 比特率和波特率之间的关系：假设：k进制码元一段数据的比特率=vb/s则:这段数据的波特率=log2​kv​Baud 带宽： ​ 单位时间通过的最高数据率。单位b/s 数字信号传输限制 数字信号不失真传输的最大速率限制 码间干扰 码间串扰 Nyquist Law 奈奎斯特定律 :exclamation: 理想低通信道上码元最高传输速率 C=2Wlog2k HzC=2Wlog_2k\\,\\,\\,Hz C=2Wlog2​kHz 任意一个信号通过一个带宽为k b/s 的信道 只要经过 2k次采样就能完重构被过滤掉的信号。 奈奎斯特采样定理（Nyquist） - MyCPlusPlus - 博客园 (cnblogs.com) 这个博客介绍了 二倍采样对原信号的复原 是个什么样的过程。 但是其中有一个 频率为1Hz的sin图像 对这个图像使用 2Hz的采样并没有很好地重构原信号。 Nyquist law 如果在采样点无法对准 波的峰值和谷值的时候是会出现不准确的 12345原因：​ 如上图，将这些采样点连成线条，得到的信号形状为三角波，虽然信号的频率成分没有失信，但是很难保证信号的幅值不失真。因为这两个采样点很难位于正弦信号的波峰与波谷处。也就是说，在很大程度上，采样后的信号的幅值是失真的。​ 很难保证信号不存在偏置值 使得采样点完美地和原始信号的波峰和波谷对应。 Nyquist Law 存在的意义： 信源发送的信号 在信道上是一种 模拟信号，并且会有局部的抖动（噪声的干扰），当这些信号传入信宿的时候 我们首先通过傅里叶变换 拟合出一个最接近这个发送过来信号的 比较平滑的 模拟信号，再使用Nyquist采样定律 采样出数字信号。 模拟信号到数字信号的转换。 Nyquist Law 有关的题目： 【问题： 为什么一个相位上面的信号有多个电平 不同的电平代表了什么？】 Shannon 香农定律 有噪声的信道上信号传输的最大速率限制 信噪比： 信号的平均功率：S噪声的平均功率：N信噪比： 10log(1+SN) (dB)信号的平均功率：S\\\\ 噪声的平均功率：N\\\\ 信噪比：\\,\\,\\,10log(1+\\frac{S}{N})\\,\\,\\,\\,(dB) 信号的平均功率：S噪声的平均功率：N信噪比：10log(1+NS​)(dB) Shannon 公式： 实际中不会像Nyquist设想的那样无噪声，Shannon提出了实际中存在噪声时信道最大数据传输速度记当前信道的带宽为 W,信号的平均功率S,噪声的平功率信号最大传输速率C=Wlog(1+SN)实际中不会像Nyquist设想的那样无噪声，Shannon提出了实际中存在噪声时信道最大数据传输速度\\\\ 记当前信道的带宽为\\,W,信号的平均功率S,噪声的平功率\\\\ 信号最大传输速率C=Wlog(1+\\frac{S}{N}) 实际中不会像Nyquist设想的那样无噪声，Shannon提出了实际中存在噪声时信道最大数据传输速度记当前信道的带宽为W,信号的平均功率S,噪声的平功率信号最大传输速率C=Wlog(1+NS​) Nyquist 定律 和Shannon 定理之间的区别： 傅里叶分析： 将空域离散数据转换到频域上。 将离散的 数字信号 转换成 模拟信号 数字离散信息–&gt; 物理信号 波信号。 物理层的传输媒体 Magnetic Media DVDs 引导型传输媒体 双绞线 twisted pair 屏蔽双绞线 shielded twisted pair 光缆 Fiber cable 同轴电缆 Coaxial Cable 光纤 Fiber Optic 非引导型传输媒体 infrared 红外线 Radio 无线电传输 satellite 卫星 微波 在空间主要是直线传播 调制方法 调幅 AM Amplitude Modulation 调频 FM Frequency Modulation 调相 PM Phase Modulation 信道复用技术 Multiplexer 频分复用 Frequency Division Multiplexing 时分复用 Time Division Multiplexing Wavelength Division Multiplexing 统计时分复用 Statistical Time Division Multiplexing 电路交换 建立连接 - 通信 - 释放连接 特点：独占资源 advantage guaranteed data rate once connected no channel delay （通信延迟小） 有序传输 没有冲突 实时性强 disadvantages: inefficient use of the transmission media （利用率低） long connection delay (at the first time ) 在第一次呼叫连接的时候有延迟 无差错控制 分组交换 traits: The connection is determined only when there is actual data (a message) ready to be sent. The whole message is recollected at each switch and then forwarded on to the next switch. store and forward（存储转发 动态分配线路） 无需建立连接 理解什么是存储转发！ 线路利用率高 【这个容易理解】 多目标服务 advantage: 相对电路交换 提高了带宽的利用率 能够根据网络情况调整数据发送线路 更短的传输延迟 重传的包更小 disadvantage： 更复杂的协议 more complex protocol 对于分组发放的设备要求更强的计算能力 越多的数据包意味着更高的出错率（丢包率） 分组交换的两种方法 数据报分组交换 数据报分组交换的过程 message被分为包流 a stream of packets 每一个包都有自己的control instruction 控制 交换设备将每一个包分别发送 数据报分组交换的特点 交换设备能够绕过拥堵路段发送数据包 每个数据包需要一个字段来使得接受设备重组 Small packet size facilitates retransmission due to errors 【更小的包体 意味着更小的回传代价】 虚电路交换 （待补充！） 报文交换","categories":[{"name":"专业课","slug":"专业课","permalink":"https://ninoneumann.cn/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://ninoneumann.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"PAT-dfs-专题","slug":"PAT-dfs-专题","date":"2022-04-27T01:46:14.000Z","updated":"2022-04-27T01:57:58.392Z","comments":true,"path":"2022/04/27/PAT-dfs-专题/","link":"","permalink":"https://ninoneumann.cn/2022/04/27/PAT-dfs-%E4%B8%93%E9%A2%98/","excerpt":"","text":"更新时间线 2022-4-27创建专题编写最短路径问题 PAT-dfs-专题 写在前面 LJ的我总是被DFS问题困扰，每次DFS的时候要么写不出来，不知道回溯递归该如何设计，要么就是写出来的WA掉【遇到这种情况是最烦的】，回溯剪枝很重要啊！但是每次我都剪枝剪了个寂寞。于是想找一个空闲一点的时间好好补补课。所以就写了这篇博客。 介绍 DFS我觉的并不是一类的问题，而是解决问题的一种方法，就像在leetcode中学习dfs的时候一开始会让你学习二叉树的遍历。所以这里不会着重介绍DFS是什么，而是会将一些经典问题结合DFS去学习。 最短路径 参考博客 最短路径问题（更新）_skycrygg的博客-CSDN博客_最短路径问题 关键字：带权图","categories":[{"name":"PAT刷题记录","slug":"PAT刷题记录","permalink":"https://ninoneumann.cn/categories/PAT%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://ninoneumann.cn/tags/algorithm/"},{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/tags/PAT/"}]},{"title":"单词复习+扩展-4-27","slug":"单词复习-扩展-4-27","date":"2022-04-27T00:46:55.000Z","updated":"2022-04-27T11:49:11.804Z","comments":true,"path":"2022/04/27/单词复习-扩展-4-27/","link":"","permalink":"https://ninoneumann.cn/2022/04/27/%E5%8D%95%E8%AF%8D%E5%A4%8D%E4%B9%A0-%E6%89%A9%E5%B1%95-4-27/","excerpt":"","text":"单词复习+扩展-4-27 复习 throne: n 王座，王权 come to the throne 继承王位 成为王 【Edward 3 came to the throne in 1327】 heir n 继承人 He’s the heir to the throne. on the throne 当权 permeate vt vi 充斥 on occasion 偶尔 有时候 confidence in I have complete confidence in you. fluctuate vi 波动 上下浮动 the game is fluctuated, but the average is in his favour. 赌局起落不定 但是平均下来，他赢的多。 diagnose vt vi the doctor diagnose me as psychopathic 医生诊断我为精神变态 be diagnosed with cancer diagnose a problem be indignant about/at sth indignation indignantly period n 一段时间 periodic adj 定期的 周期的 periodical adj 定期的 周期的 chip n 薯片 芯片 vt 凿下 切下 chip away with his chisel benign adj 善良的 良性的 he is a benign person a benign tumour propaganda 注意拼写 lag behind 落后 come on don’t lag 走吧 别磨蹭了 feat n 壮举 技艺 a remarkable feat 了不起的壮举 starlight illuminate the night sky be severely depleted 被大幅度消耗 大幅度减少 use your discretion 酌情处理 elicit vt 诱导 引出 套出 elicit a response 引起反应 elicit a defensive reaction from me when you do that . imminent adj 即将发生的 in imminent danger 面临危险 an imminent threat 临近的威胁 a kick from such a large animal would ==inflict serious injury.== 造成严重的伤害 the damage inflicted on the city inflict sth1 on sth2 the FBI has no jurisdiction over us sth has no jurisdiction over us it is outside of my jurisdiction. it ==stipulates== that Hon Kong’s current social and economic systems would remain untouched after 1997. She stpulated that I have to be married by my 30th birthday. the weather won’t ==deter== him ==from== ==venturing deeper into the mountains==. my happiness is contingent on yours. the speech is full of empty rhetoric regent n 摄政王 （学术机构）董事 adj 摄政的 burgeon adj 迅速生长 快速发展 a burgeoning need 激增的需求 a burgeoning market 迅速发展的市场 a burgeoning technology 快速发展的技术 the hacker crowd has burgeoned and mutated 黑客组织快速的发展 并且发生了变化 methane n 甲烷 consortium n 财团 联合企业 a consortium of European firms buckle n 皮带塔扣 curry n 咖喱 subliminal adj 下意识的 潜意识的 a subliminal message he is subjected to subliminal suggestions of a violent nature chamber n 房间 the burial chamber 墓室 excavate vt 挖掘 开凿 excavate a tunnel 开凿隧道 excavate a cave 挖洞穴 hectare n 公顷 forfeit vt 失去 丧失 forfeit the right to rule 丧失统治权","categories":[{"name":"每日英语单词","slug":"每日英语单词","permalink":"https://ninoneumann.cn/categories/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"英语","slug":"英语","permalink":"https://ninoneumann.cn/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"单词","slug":"单词","permalink":"https://ninoneumann.cn/tags/%E5%8D%95%E8%AF%8D/"}]},{"title":"人工神经网络-课程实验-1","slug":"人工神经网络-课程实验-1","date":"2022-04-26T00:42:17.000Z","updated":"2022-06-16T01:23:52.022Z","comments":true,"path":"2022/04/26/人工神经网络-课程实验-1/","link":"","permalink":"https://ninoneumann.cn/2022/04/26/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C-1/","excerpt":"","text":"人工神经网络-课程实验-1 题目1： 描述： （该网络包括4个Affine仿射层，每一层的神经元个数分别为100，100，50，10；3个ReLU激活层以及一个Softmax层，并采用Cross-Entropy Loss损失函数。使用SGD迭代法更新网络参数。） 题目2： 描述： （该网络包括3个Convention卷积层；4个ReLU激活层；2个pooling池化层；2个Affine仿射层以及一个Softmax层，采用Cross-Entropy Loss损失函数。注意，该网络中卷积层的卷积核的数量，大小，填充和步幅，池化层的窗口大小、步幅，仿射层的神经元的个数等参数由自己决定，但需要在文档中给出每一层的参数说明。使用SGD迭代法更新网络参数。） 架构实现 作业1 代码说明文档 使用pytorch框架 构建管理超参数的config 类 123456789class config(): def __init__(self): self.input_size = 28 * 28 # 指定输入的大小 self.output_size = 10 # 指定输出大小 self.batch_size = 110 # 指定batch大小 self.epoch = 1000 # 指定训练的总epoch数 self.lr = 0.01 # 学习率 self.momentum = 0.5 # momentum self.device = &quot;cuda&quot; # 使用的device &quot;cuda&quot; 网络的构建 按照要求做的四层网络 （该网络包括4个Affine仿射层，每一层的神经元个数分别为100，100，50，10 ；3个ReLU激活层以及一个Softmax层，并采用Cross-Entropy Loss损失函数。 使用SGD迭代法更新网络参数。） 12345678910111213141516import torchimport torch.nn as nnclass MyNet(nn.Module): def __init__(self, input_size=28 * 28, output_size=10): super().__init__() self.layer1 = nn.Sequential(nn.Linear(in_features=input_size, out_features=100), nn.ReLU()) self.layer2 = nn.Sequential(nn.Linear(in_features=100, out_features=100), nn.ReLU()) self.layer3 = nn.Sequential(nn.Linear(in_features=100, out_features=50), nn.ReLU()) self.layer4 = nn.Sequential(nn.Linear(in_features=50, out_features=output_size), nn.Softmax()) def forward(self, x): x = self.layer1(x) x = self.layer2(x) x = self.layer3(x) x = self.layer4(x) return x 训练函数的构建 12345678910111213141516171819def train(model, train_loader, cfg, optimizer, criterion): train_loss = 0 train_acc = 0 for img, label in train_loader: img = img.to(cfg.device) label = label.to(cfg.device) img = img.view(img.size(0), -1) out = model(img) loss = criterion(out, label) optimizer.zero_grad() loss.backward() optimizer.step() train_loss += loss.item() pred = out.argmax(dim=1) # 找出batch中各个图片在10个类别中最匹配的类别，也就是说模型将该图片预测成该类别，argmax()可以找到最大值的索引，dim=1表示沿着列的方向找最大值。 train_acc += (pred == label).sum().item() / img.size(0) # 计算准确率，统计这128张图片（一个batch大小）中预测对的个数，然后除以128，这就是这个batch的准确率。pred和label的形状都是（128, 1），pred==label中，如果二者对应的值相等则为True，否则为False，sum()可以统计出128个值中有多少个True，item()变成数字。img.size(0)是128，因为img的size是[128, 1, 28, 28]。 train_loss = train_loss / len(train_loader) train_acc = train_acc / len(train_loader) return train_loss, train_acc 测试函数的构建 1234567891011121314151617181920212223242526import torch@torch.no_grad()def test(model, test_loader, cfg, optimizer, criterion)-&gt;(float,float): &#x27;&#x27;&#x27; 测试使用的函数 :param model: 训练 使用的模型 :param test_loader: 测试的dataloader :param cfg: config 类 :param optimizer: 优化器 :param criterion: 损失函数 :return: test过程的loss 和 准确率 acc &#x27;&#x27;&#x27; test_loss = 0 test_acc = 0 for img, label in test_loader: img = img.to(cfg.device) label = label.to(cfg.device) img = img.view(img.size(0), -1) out = model(img) loss = criterion(out, label) test_loss += loss.item() pred = out.argmax(dim=1) test_acc += (pred == label).sum().item() / img.size(0) test_loss = test_loss / len(test_loader) test_acc = test_acc / len(test_loader) return test_loss, test_acc 数据集的加载和数据的归一化 123456789101112131415from torchvision.datasets import mnistimport torchvision.transforms as transformsfrom torch.utils.data import DataLoadercfg = config() # 上面有# 数据集加载# 数据的归一化transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize([0.5], [0.5])])train_dataset = mnist.MNIST(&#x27;./data&#x27;, train=True, transform=transform, download=True)test_dataset = mnist.MNIST(&#x27;./data&#x27;, train=False, transform=transform)# 创建数据集迭代对象，但不是迭代器，可以使用for循环，不能使用nexttrain_loader = DataLoader(train_dataset, batch_size=cfg.batch_size, shuffle=True)test_loader = DataLoader(test_dataset, batch_size=cfg.batch_size, shuffle=False) 定义损失函数和优化器 123456import torchimport torch.nn as nnimport torch.optim as opt# 定义损失函数和优化器criterion = nn.CrossEntropyLoss() # 交叉熵损失作为 损失函数optimizer = opt.SGD(model.parameters(), lr=cfg.lr, momentum=cfg.momentum) 主程序 12345678910111213141516171819202122232425262728def main(): cfg = config() # 数据集加载 # 数据的归一化 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize([0.5], [0.5])]) train_dataset = mnist.MNIST(&#x27;./data&#x27;, train=True, transform=transform, download=True) test_dataset = mnist.MNIST(&#x27;./data&#x27;, train=False, transform=transform) # 创建数据集迭代对象，但不是迭代器，可以使用for循环，不能使用next train_loader = DataLoader(train_dataset, batch_size=cfg.batch_size, shuffle=True) test_loader = DataLoader(test_dataset, batch_size=cfg.batch_size, shuffle=False) # 创建model model = MyNet(cfg.input_size).to(cfg.device) # 定义损失函数和优化器 criterion = nn.CrossEntropyLoss() # 交叉熵损失作为 损失函数 optimizer = opt.SGD(model.parameters(), lr=cfg.lr, momentum=cfg.momentum) # 开始训练 for i in range(cfg.epoch): train_loss, train_acc = train(model, train_loader, cfg, optimizer, criterion) test_loss, test_acc = test(model, train_loader, cfg, optimizer, criterion) # 日志输出 print(&quot;Epoch: &#123;&#125;, Train loss: &#123;&#125;, Train acc: &#123;&#125;, Test loss: &#123;&#125;, Test acc: &#123;&#125;&quot;.format(i, train_loss, train_acc, test_loss, test_acc)) 作业2 代码说明文档 使用pytorch框架 构建管理超参数的config 类 12345678910class config: def __init__(self): self.input_size = 28 * 28 # 指定输入的大小 self.output_size = 10 # 指定输出大小 self.batch_size = 110 # 指定batch大小 self.epoch = 1000 # 指定训练的总epoch数 self.lr = 0.01 # 学习率 self.momentum = 0.5 # momentum self.device = &quot;cuda&quot; # 使用的device &quot;cuda&quot; 网络的构建 按照要求做的网络 12345678910111213141516171819202122232425262728293031import torchimport torch.nn as nnclass MyNet2(nn.Module): def __init__(self): super().__init__() self.conv1 = nn.Sequential( nn.Conv2d(in_channels=1, out_channels=8, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2, 2, 2)), nn.ReLU(), nn.MaxPool2d(kernel_size=2)) # Bx8x14x14 self.conv2 = nn.Sequential( nn.Conv2d(in_channels=8, out_channels=16, kernel_size=(5, 5), padding=(2, 2, 2, 2)), nn.ReLU(), nn.MaxPool2d(kernel_size=2)) # Bx16x7x7 self.conv3 = nn.Sequential( nn.Conv2d(in_channels=16, out_channels=32, kernel_size=(3, 3), padding=(1, 1, 1, 1)), nn.ReLU()) # Bx32x7x7 self.flatten = nn.Flatten() self.layer4 = nn.Sequential( nn.Linear(in_features=32 * 7 * 7, out_features=100), nn.ReLU()) self.layer5 = nn.Sequential( nn.Linear(in_features=100, out_features=10), nn.Softmax()) def forward(self, x): x = self.conv1(x) x = self.conv2(x) x = self.conv3(x) x = self.flatten(x) x = self.layer4(x) x = self.layer5(x) return x self.conv1: conv2d 输入channel 1 输出channel 8 卷积核 （5, 5） padding (2,2,2,2) 四个边的padding 都是2 为了让卷积之后的图片大小不变 relu 激活函数 maxpooling kernel size = 2 self.conv1 层的输入(B,1,28,28) -&gt; 输出 (B,8,14,14) self.conv2: conv2d 输入channel 8 输出channel 16 卷积核 （5, 5） padding (2,2,2,2) 四个边的padding 都是2 为了让卷积之后的图片大小不变 relu 激活函数 maxpooling kernel size = 2 self.conv2 层的输入(B,8,14,14) -&gt; 输出 (B,16,7,7) self.conv3: conv2d 输入channel 16 输出channel 32 卷积核 （3, 3） padding (1,1,1,1) 四个边的padding 都是1 为了让卷积之后的图片大小不变 relu 激活函数 self.conv2 层的输入(B,16,7,7) -&gt; 输出 (B,32,7,7) self.flatten: Flatten: 让三维图像平铺 self.flatten 层的输入(B,32,7,7) -&gt; 输出 (B,32 * 7 * 7) self.layer4: 仿射层 输入32 * 7 * 7 输出 100 self。layer5: 仿射层 输入100 输出10 训练函数的构建 1234567891011121314151617def train(model, train_loader, cfg, optimizer, criterion): train_loss = 0 train_acc = 0 for img, label in train_loader: img = img.to(cfg.device) label = label.to(cfg.device) out = model(img) loss = criterion(out, label) optimizer.zero_grad() loss.backward() optimizer.step() train_loss += loss.item() pred = out.argmax(dim=1) # 找出batch中各个图片在10个类别中最匹配的类别，也就是说模型将该图片预测成该类别，argmax()可以找到最大值的索引，dim=1表示沿着列的方向找最大值。 train_acc += (pred == label).sum().item() / img.size(0) # 计算准确率，统计这128张图片（一个batch大小）中预测对的个数，然后除以128，这就是这个batch的准确率。pred和label的形状都是（128, 1），pred==label中，如果二者对应的值相等则为True，否则为False，sum()可以统计出128个值中有多少个True，item()变成数字。img.size(0)是128，因为img的size是[128, 1, 28, 28]。 train_loss = train_loss / len(train_loader) train_acc = train_acc / len(train_loader) return train_loss, train_acc 测试函数的构建 12345678910111213141516171819202122232425import torch@torch.no_grad()def test(model, test_loader, cfg, criterion)-&gt;(float,float): &#x27;&#x27;&#x27; 测试使用的函数 :param model: 训练 使用的模型 :param test_loader: 测试的dataloader :param cfg: config 类 :param optimizer: 优化器 :param criterion: 损失函数 :return: test过程的loss 和 准确率 acc &#x27;&#x27;&#x27; test_loss = 0 test_acc = 0 for img, label in test_loader: img = img.to(cfg.device) label = label.to(cfg.device) out = model(img) loss = criterion(out, label) test_loss += loss.item() pred = out.argmax(dim=1) test_acc += (pred == label).sum().item() / img.size(0) test_loss = test_loss / len(test_loader) test_acc = test_acc / len(test_loader) return test_loss, test_acc 数据集的加载和数据的归一化 123456789101112131415from torchvision.datasets import mnistimport torchvision.transforms as transformsfrom torch.utils.data import DataLoadercfg = config() # 上面有# 数据集加载# 数据的归一化transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize([0.5], [0.5])])train_dataset = mnist.MNIST(&#x27;./data&#x27;, train=True, transform=transform, download=True)test_dataset = mnist.MNIST(&#x27;./data&#x27;, train=False, transform=transform)# 创建数据集迭代对象，但不是迭代器，可以使用for循环，不能使用nexttrain_loader = DataLoader(train_dataset, batch_size=cfg.batch_size, shuffle=True)test_loader = DataLoader(test_dataset, batch_size=cfg.batch_size, shuffle=False) 定义损失函数和优化器 123456import torchimport torch.nn as nnimport torch.optim as opt# 定义损失函数和优化器criterion = nn.CrossEntropyLoss() # 交叉熵损失作为 损失函数optimizer = opt.SGD(model.parameters(), lr=cfg.lr, momentum=cfg.momentum) 主程序 12345678910111213141516171819202122232425262728def main(): cfg = config() # 数据集加载 # 数据的归一化 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize([0.5], [0.5])]) train_dataset = mnist.MNIST(&#x27;./data&#x27;, train=True, transform=transform, download=True) test_dataset = mnist.MNIST(&#x27;./data&#x27;, train=False, transform=transform) # 创建数据集迭代对象，但不是迭代器，可以使用for循环，不能使用next train_loader = DataLoader(train_dataset, batch_size=cfg.batch_size, shuffle=True) test_loader = DataLoader(test_dataset, batch_size=cfg.batch_size, shuffle=False) # 创建model model = MyNet(cfg.input_size).to(cfg.device) # 定义损失函数和优化器 criterion = nn.CrossEntropyLoss() # 交叉熵损失作为 损失函数 optimizer = opt.SGD(model.parameters(), lr=cfg.lr, momentum=cfg.momentum) # 开始训练 for i in range(cfg.epoch): train_loss, train_acc = train(model, train_loader, cfg, optimizer, criterion) test_loss, test_acc = test(model, train_loader, cfg, criterion) # 日志输出 print(&quot;Epoch: &#123;&#125;, Train loss: &#123;&#125;, Train acc: &#123;&#125;, Test loss: &#123;&#125;, Test acc: &#123;&#125;&quot;.format(i, train_loss, train_acc, test_loss, test_acc)) 测试数据的可视化 为什么作业1 会有一个向上的跳变？？","categories":[{"name":"专业课","slug":"专业课","permalink":"https://ninoneumann.cn/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://ninoneumann.cn/tags/AI/"},{"name":"CNN","slug":"CNN","permalink":"https://ninoneumann.cn/tags/CNN/"}]},{"title":"hexo-博客渲染伪代码教程","slug":"hexo-博客渲染伪代码教程","date":"2022-04-25T03:23:27.000Z","updated":"2022-05-11T10:08:42.469Z","comments":true,"path":"2022/04/25/hexo-博客渲染伪代码教程/","link":"","permalink":"https://ninoneumann.cn/2022/04/25/hexo-%E5%8D%9A%E5%AE%A2%E6%B8%B2%E6%9F%93%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%95%99%E7%A8%8B/","excerpt":"","text":"更新时间线 2022-4-25 更新编写教程初步 hexo 博客 渲染伪代码教程 warning: 使用本教程需要你在之后的撰写伪代码的过程中具备Latex编写伪代码的知识 我使用的是typora+markdown+hexo来编写和生成静态网络，typora中支持pseudocode的代码框但是无法最pseudocode进行渲染。 在参考了以下的博客之后我找到了这个git仓库中的内容： 参考 SaswatPadhi/pseudocode.js: Beautiful pseudocode for the Web (github.com)https://zjuguoshuai.gitlab.io/2019/04/26/blog-pseudocode.html hexo渲染pseudocode的状态 12345678910111213141516171819202122232425% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)\\begin&#123;algorithm&#125;\\caption&#123;Quicksort&#125;\\begin&#123;algorithmic&#125;\\PROCEDURE&#123;Quicksort&#125;&#123;$A, p, r$&#125; \\IF&#123;$p &lt; r$&#125; \\STATE $q = $ \\CALL&#123;Partition&#125;&#123;$A, p, r$&#125; \\STATE \\CALL&#123;Quicksort&#125;&#123;$A, p, q - 1$&#125; \\STATE \\CALL&#123;Quicksort&#125;&#123;$A, q + 1, r$&#125; \\ENDIF\\ENDPROCEDURE\\PROCEDURE&#123;Partition&#125;&#123;$A, p, r$&#125; \\STATE $x = A[r]$ \\STATE $i = p - 1$ \\FOR&#123;$j = p$ \\TO $r - 1$&#125; \\IF&#123;$A[j] &lt; x$&#125; \\STATE $i = i + 1$ \\STATE exchange $A[i]$ with $A[j]$ \\ENDIF \\STATE exchange $A[i]$ with $A[r]$ \\ENDFOR\\ENDPROCEDURE\\end&#123;algorithmic&#125;\\end&#123;algorithm&#125; 教程步骤： 添加依赖头： warning: 请在 _config.butterfly.yml中的inject中添加以下内容 12345678910# 这里只需要添加head部分的三个依赖 和 一个放在bottom的渲染代码就ok 了！inject: head: # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt; - .... # 省略 这边的 ... 是你自己添加的放在head的部分依赖 - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css&quot;&gt; - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js&quot;&gt;&lt;/script&gt; - &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js&quot; integrity=&quot;sha256-F/Xda58SPdcUCr+xhSGz9MA2zQBPb0ASEYKohl8UCHc=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; bottom: - &lt;script&gt;pseudocode.renderElement(document.getElementById(&quot;quicksort&quot;));&lt;/script&gt; 样例结果以及源代码预览 样式预览样例源码 % This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition) \\begin{algorithm} \\caption{Quicksort} \\begin{algorithmic} \\PROCEDURE{Quicksort}{$A, p, r$} \\IF{$p < r$} \\STATE $q = $ \\CALL{Partition}{$A, p, r$} \\STATE \\CALL{Quicksort}{$A, p, q - 1$} \\STATE \\CALL{Quicksort}{$A, q + 1, r$} \\ENDIF \\ENDPROCEDURE \\PROCEDURE{Partition}{$A, p, r$} \\STATE $x = A[r]$ \\STATE $i = p - 1$ \\FOR{$j = p$ \\TO $r - 1$} \\IF{$A[j] < x$} \\STATE $i = i + 1$ \\STATE exchange $A[i]$ with $A[j]$ \\ENDIF \\STATE exchange $A[i]$ with $A[r]$ \\ENDFOR \\ENDPROCEDURE \\end{algorithmic} \\end{algorithm} 其实是一个html元素然后包含一个Katex的描述伪代码的源码语言 123456789101112131415161718192021222324252627&lt;pre id=&quot;quicksort&quot; class=&quot;pseudocode&quot; style=&quot;display:hidden;&quot;&gt; % This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition) \\begin&#123;algorithm&#125; \\caption&#123;Quicksort&#125; \\begin&#123;algorithmic&#125; \\PROCEDURE&#123;Quicksort&#125;&#123;$A, p, r$&#125; \\IF&#123;$p &lt; r$&#125; \\STATE $q = $ \\CALL&#123;Partition&#125;&#123;$A, p, r$&#125; \\STATE \\CALL&#123;Quicksort&#125;&#123;$A, p, q - 1$&#125; \\STATE \\CALL&#123;Quicksort&#125;&#123;$A, q + 1, r$&#125; \\ENDIF \\ENDPROCEDURE \\PROCEDURE&#123;Partition&#125;&#123;$A, p, r$&#125; \\STATE $x = A[r]$ \\STATE $i = p - 1$ \\FOR&#123;$j = p$ \\TO $r - 1$&#125; \\IF&#123;$A[j] &lt; x$&#125; \\STATE $i = i + 1$ \\STATE exchange $A[i]$ with $A[j]$ \\ENDIF \\STATE exchange $A[i]$ with $A[r]$ \\ENDFOR \\ENDPROCEDURE \\end&#123;algorithmic&#125; \\end&#123;algorithm&#125;&lt;/pre&gt; 使用方法以及注意事项 key: 注意之后如果想添加伪代码块请务必使用如下html标签包裹 warning: 如下的html标签中 Class属性一定要指定成class=&quot;pseudocode&quot; !!! 123&lt;pre id=&quot;pseudocode&quot; class=&quot;pseudocode&quot; style=&quot;display:hidden;&quot;&gt; % this is the pseudocode block where you can write.&lt;/pre&gt; 之后就能快乐地coding了 nice！ pseudocode.renderElement(document.getElementById(\"quicksort\"));","categories":[{"name":"hexo魔改","slug":"hexo魔改","permalink":"https://ninoneumann.cn/categories/hexo%E9%AD%94%E6%94%B9/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ninoneumann.cn/tags/hexo/"},{"name":"博客魔改","slug":"博客魔改","permalink":"https://ninoneumann.cn/tags/%E5%8D%9A%E5%AE%A2%E9%AD%94%E6%94%B9/"},{"name":"伪代码","slug":"伪代码","permalink":"https://ninoneumann.cn/tags/%E4%BC%AA%E4%BB%A3%E7%A0%81/"}]},{"title":"编译原理-词法分析程序的构建-语法分析程序的构建","slug":"编译原理-词法分析程序的构建","date":"2022-04-25T02:15:40.000Z","updated":"2022-05-11T10:14:43.797Z","comments":true,"path":"2022/04/25/编译原理-词法分析程序的构建/","link":"","permalink":"https://ninoneumann.cn/2022/04/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E5%BB%BA/","excerpt":"","text":"更新时间线 咕咕咕了一两周了，我意识到不能这样了，所以来完成语法分析程序以及之后的内容了。都两周了所以我对之前的词法分析程序进行一次再理解+重构添加语法分析2022-4-26更新一些子程序的程序执行流程图2022-4-25梳理如何构建一个词法分析程序 （我TM为啥没有好好听课！！！）绘图工具的准备绘制词法规则转换图添加伪代码编写工具分析程序绘制状态转换图创建git仓库 存放代码 编译原理-词法分析程序的构建 目标 将下面将下面的文法规则中词法抽离出来并构建词法分析程序 1234567891011121314151617181920212223242526架空语言的文法规则： &lt;程序&gt; →&lt;变量说明部分&gt;;&lt;语句部分&gt;&lt;变量说明部分&gt; → &lt;变量说明&gt;&lt;标识符列表&gt;&lt;变量说明&gt; → int&lt;标识符列表&gt; → &lt;标识符列表&gt;,&lt;标识符&gt;|&lt;标识符&gt;&lt;标识符&gt; → $&lt;字母&gt;|&lt;标识符&gt;&lt;字母&gt;|&lt;标识符&gt;&lt;数字&gt;&lt;语句部分&gt; → &lt;语句部分&gt;&lt;语句&gt;;|&lt;语句&gt;;&lt;语句&gt; → &lt;赋值语句&gt;|&lt;条件语句&gt;|&lt;循环语句&gt;|&lt;赋值语句&gt; → &lt;标识符&gt;=&lt;表达式&gt;&lt;条件语句&gt; → if （&lt;条件&gt;） then &lt;嵌套语句&gt;; else &lt;嵌套语句&gt;&lt;循环语句&gt; → while （&lt;条件&gt;） do &lt;嵌套语句&gt;&lt;表达式&gt; → &lt;项&gt;|&lt;表达式&gt;&lt;加法运算符&gt;&lt;项&gt;&lt;项&gt; → &lt;因子&gt;|&lt;项&gt;&lt;乘法运算符&gt;&lt;因子&gt;&lt;因子&gt; → &lt;标识符&gt;|&lt;常量&gt;|(&lt;表达式&gt;)&lt;常量&gt; → &lt;无符号整数&gt;&lt;无符号整数&gt; → &lt;数字序列&gt;&lt;数字序列&gt; → &lt;数字序列&gt;&lt;数字&gt;|&lt;数字&gt;&lt;加法运算符&gt; → +&lt;乘法运算符&gt; → *&lt;关系运算符&gt; → &lt;|&gt;|!= |&gt;=|&lt;= |== &lt;条件&gt; → &lt;表达式&gt;&lt;关系运算符&gt;&lt;表达式&gt;&lt;复合语句&gt; → begin &lt;语句部分&gt; end&lt;嵌套语句&gt; → &lt;语句&gt;|&lt;复合语句&gt;&lt;字母&gt; → a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z&lt;数字&gt; → 0|1|2|3|4|5|6|7|8|9 工具的准备 绘图工具 Graphviz 我这里使用Graphviz+python的模式绘图如果你会Graphviz的原生编程语言可以不用python 伪代码编写工具 hexo无法渲染pseudocode代码所以需要自己魔改一下 blog显示伪代码工具已就绪 使用latex做伪代码的显示 （我实在不知道latex怎么在typora中显示） 构建词法分析程序的步骤 基本步骤： 从文法中抽离词法 将词法形成状态转换图 形成 DFA 或者 NFA 对DFA 或者 NFA进行处理 化简 在编写程序的时候首先要定义各个符号的value 分析程序 其实词法是文法的一部分 词法分析程序由于繁琐复杂所以将其抽离出来 将词法简单地抽离出来后我们发现这有可能是一个NFA (不确定的有穷自动机) 这时候就需要我们将 NFA DFA化 词法分析程序的入口和出口 入口：一般是读入一段自己编写的程序 这里让程序读入txt文本 出口：词法分析程序所输出 的单词符号可以采用二元式表示(单词种别，单词自身的值) 关于出口的二元式当单词为标识符的时候 二元式中单词自身的值可以作为该标识符在符号表中所置的位置指针。 从文法中抽离词法 1、我们该抽离哪些内容： 关键字 1&lt;关键字&gt; → if|else|then|do|while|begin|end|int 标识符 1&lt;标识符&gt; → $&lt;字母&gt;|&lt;标识符&gt;&lt;字母&gt;|&lt;标识符&gt;&lt;数字&gt; 常数 1&lt;常量&gt; → &lt;无符号整数&gt; 运算符 1234&lt;加法运算符&gt; → +&lt;乘法运算符&gt; → *&lt;关系运算符&gt; → &lt;|&gt;|!= |&gt;=|&lt;= |== &lt;赋值运算符&gt; → = 界符 1&lt;界符&gt; → ;|,|(|) 符号的对应value的定义 由于词法分析程序需要输出的是一个二元式 (单词种别，单词自身的值)所以需要对各种的单词进行一个种类赋值 各个符号种类对应的value各个符号种类对应的value的解释123456789101112131415161718192021222324// 给各个符号进行如下的赋值#define ID_CONSTANT 0 #define ID_INT 1 #define ID_IF 2 #define ID_ELSE 3 #define ID_THEN 4#define ID_WHILE 5 #define ID_BEGIN 6#define ID_END 7#define ID_DO 8 #define ID_PLUS 9 #define ID_MUL 10 #define ID_LT 11 #define ID_GT 12 #define ID_NE 13#define ID_GE 14#define ID_LE 15#define ID_EQ 16#define ID_COMMA 17#define ID_SEMICOLON 18#define ID_LBRACE 19#define ID_RBRACE 20#define ID_GIVE 21#define ID_IDENTIFIER 22 123456789101112131415161718192021222324/* 0 &lt;constant&gt; * 1 int * 2 if * 3 else * 4 then * 5 while * 6 do * 7 begin * 8 end * 9 + * 10 * * 11 &lt; * 12 &gt; * 13 != * 14 &gt;= * 15 &lt;= * 16 == * 17 , * 18 ; * 19 ( * 20 ) * 21 = * 22 &lt;Identifiers&gt; * */ 绘制词法规则转换图 有些不标准 但是没有找到更好的绘制状态图的工具所以先用着 关键字DFA标识符的DFA 算法伪代码 ​ 程序框图 总程序执行流程图 扫描子程序的程序框图： 语法分析 在完成了词法分析，生成了二元式之后。我们接下来要做的就是对程序进行语法分析： 语法分析和词法分析的互动 按照书上说，语法分析和词法分析其实是同时进行的，对（自定义规则的）程序进行语法分析的时候，语法分析程序会调用词法分析程序，每次调用（词法分析程序）都会产生一个“东西”给语法分析程序进行判断。 123456flowchart TDA[调用词法分析程序]--&gt;B&#123;能否进行规约/推导&#125;B--yes--&gt;D[推导/规约]B--No--&gt;E[OUT]D--&gt;F[调用语义分析]F--&gt;A 上下文无关文法 下推自动机 PDA 语法分析的方法 语法分析有一些方法，这里按照实验手册的要求使用**“递归下降分析技术”** 递归下降分析技术 递归下降法分析技术是top-down（自上而下的分析技术中的一种） 自上而下的分析技术不确定的分析方法：回溯法 自上而下的分析技术确定的分析方法： 递归下降法（递归下降分析技术）、预测分析法 掌握“递归下降分析技术”的一个要点是掌握判断一个文法是否是LL1文法，并且需要掌握将一个非LL1文法转换到LL1文法的方法 LL1文法： L：从左往右扫描 Left-to-Right L：采用最左推导 1：读头下的符号a就能确定候选式 绝大多数的程序语言采用LL1就能完全消除回溯 根据读头a开始的k个符号记作LL(k) 文法 LL1文法是上下文无关文法（CFG）的一个子集 LL1文法特征： 不含左递归 无回溯 每次推导只有一个候选式 首符集 First集合 存在的意义是让我们在最每个语法进行编程判断的时候能够消除回溯。 First集合的判断： 不包含空串： 包含空串： 空串处理： 非LL1文法转换为LL1文法 消除回溯： 提取左公因子 消除左递归 消除左递归很重要！ 在消除左递归的过程中我们只关心出现在产生式右侧的第一个和左侧字母相同的大写字母且只关心这一个！！ 语法分析实现： 1、pareserMainfunction parseProgram： 1&lt;程序&gt; →&lt;变量说明部分&gt;;&lt;语句部分&gt; % $ParseProgram$ 程序伪代码 \\begin{algorithm} \\caption{$ParseProgram$ 程序伪代码} \\begin{algorithmic} \\Require void \\Ensure void \\Procedure{ParseProgram}{String matchChar} \\State \\Call{ParseVariableStatements}{void} // 解析变量的声明和定义 \\State \\Call{Match}{\";\"} // 解析“;” 分隔符号 \\If{Match程序报错} \\State \\Call{ErrorProgressing}{parameters} // 异常处理 \\EndIf \\State \\Call{ParsePhrase}{void} // 解析程序语句 \\EndProcedure \\end{algorithmic} \\end{algorithm} 1、match()程序的实现 match()需要做到匹配你所指定的标识符：如果不是你所指定的标识符那么就会报错也就是将bHaveError设置为true match()程序流程图 ![未命名文件 (1)](编译原理-词法分析程序的构建/未命名文件 (1).png) \\begin{algorithm} \\caption{$Match$ 程序伪代码} \\begin{algorithmic} \\Require String matchChar 带匹配字符 \\Ensure void \\Procedure{Match}{String matchChar} \\If{读头下的二元式type$\\neq$matchChar} \\State $bHaveError \\gets true$ \\EndIf \\EndProcedure \\end{algorithmic} \\end{algorithm} 1、识别语句 1234&lt;语句部分&gt; → &lt;语句部分&gt;&lt;语句&gt;;|&lt;语句&gt;;// 需要消除左递归&lt;语句部分&gt; → &lt;语句&gt;;&lt;语句部分1&gt;&lt;语句部分1&gt; → &lt;语句&gt;;&lt;语句部分1&gt;|epsilion 1、识别标识符列表 识别标识符列表的时候出现了左递归，那么进行左递归的消除。 12345&lt;标识符列表&gt; → &lt;标识符列表&gt;,&lt;标识符&gt;|&lt;标识符&gt;消除左递归&lt;标识符列表&gt; → &lt;标识符&gt;&lt;标识符列表_1&gt;&lt;标识符列表_1&gt; → ,&lt;标识符&gt;&lt;标识符列表_1&gt;|epsilion 识别标识符列表程序的伪代码展示： 样式预览样例源码 \\begin{algorithm} \\caption{$ParseIdentifiersList$ 解析标识符列表的语法分析程序1} \\begin{algorithmic} \\Require 由Scanner()程序产生的二元式(存放在全局变量 wdNextWord中) \\Ensure void \\Procedure{ParseIdentifiersList}{void} \\State Match(); // 匹配标识符 \\State \\Call{ParseIdentifiersList1}{void}; \\EndProcedure \\Procedure{ParseIdentifiersList1}{void} \\If{读头指针下不为空符号串} \\State Match(\",\"); // 匹配“,”符号 \\State Match(); // 匹配标识符 \\State \\Call{ParseIdentifiersList1}{void}; \\Else \\State do nothing \\EndIf \\EndProcedure \\end{algorithmic} \\end{algorithm} 其实是一个html元素然后包含一个Katex的描述伪代码的源码语言 12345678910111213141516171819202122&lt;pre id=&quot;pseudocode&quot; class=&quot;pseudocode&quot; style=&quot;display:hidden;&quot;&gt; \\begin&#123;algorithm&#125; \\caption&#123;$ParseIdentifiersList$ 解析标识符列表的语法分析程序1&#125; \\begin&#123;algorithmic&#125; \\Require 由Scanner()程序产生的二元式(存放在全局变量 wdNextWord中) \\Ensure void \\Procedure&#123;ParseIdentifiersList&#125;&#123;void&#125; \\State Match(); // 匹配标识符 \\State \\Call&#123;ParseIdentifiersList1&#125;&#123;void&#125;; \\EndProcedure \\Procedure&#123;ParseIdentifiersList1&#125;&#123;void&#125; \\If&#123;读头指针下不为空符号串&#125; \\State Match(&quot;,&quot;); // 匹配“,”符号 \\State Match(); // 匹配标识符 \\State \\Call&#123;ParseIdentifiersList1&#125;&#123;void&#125;; \\Else \\State do nothing \\EndIf \\EndProcedure \\end&#123;algorithmic&#125; \\end&#123;algorithm&#125;&lt;/pre&gt; 1、表达式这边的语法的规整： 1234&lt;表达式&gt; → &lt;项&gt;|&lt;表达式&gt;&lt;加法运算符&gt;&lt;项&gt;&lt;表达式&gt; → &lt;项&gt;&lt;表达式1&gt;&lt;表达式1&gt; → &lt;加法运算符&gt;&lt;项&gt;&lt;表达式1&gt;|epsilion 1、项 12345&lt;项&gt; → &lt;因子&gt;|&lt;项&gt;&lt;乘法运算符&gt;&lt;因子&gt;&lt;项&gt; → &lt;因子&gt;&lt;项1&gt;&lt;项1&gt; → &lt;乘法运算符&gt;&lt;因子&gt;&lt;项1&gt;|epsilion 遇到的一些问题： freopen重定向导致控制台输入无效从而使得system(“pause”)无效 freopen（）重定向的打开和关闭 - Rogn - 博客园 (cnblogs.com) 在写代码时常出现这种情况：我们从原有文件使用freopen导入数据，但之后关闭文件再次从键盘输入。我们如果直接fclose(stdin)，之后的键盘输入肯定不管用。应如何解决？ 显然，如果在使用完freopen之后，如果还需要使用标准输入输出，不能把它们直接fclose。 我们不妨再次重定向，把stdin、stdout重定向到控制台，就能从键盘接受输入、从屏幕输出。 说白了我使用了freopen 将stdin重定向到目标位文件之后需要再将stdin重定向回到控制台。 头文件中变量的声明和定义 问题描述： 在对程序进行重构的过程中发现将变量的定义放到头文件中于是会在之后的应用中 特别是 头文件出现在多个cpp文件中的时候导致变量被多次定义 变量的空间被多次开辟 进而导致变量的重复“定义”！ 解决方法： 添加extern 关键字 他只声明变量而不会为变量开辟空间。 特别的： 头文件中应使用extern 关键字声明全局变量（不定义），如果这个变量有多个文件用到，可以新建一个cpp，在其中定义，把这个cpp加入工程即可。头文件请不要定义任何变量，那是非常业余的行为…… 一般在头文件中申明，用extern, 在cpp中定义。 如果在头文件中定义，如果这个头文件被多个cpp引用，会造成重复定义的链接错误。 头文件只能申明全局变量（extern），不可定义（不推荐使用） .cpp里，在最外层定义即可（int gi），直接引用 所以最好是新建一个cpp 将一些变量定义 加入到其中。 在实际的使用中如果在头文件中声明一个数组变量而在cpp中使用它的时候使用for(auto x: arr)这样的循环来遍历 那么会出现问题。 错误 C3316 “std::string []”: 大小未知的数组不能在基于范围的语句中使用 解决这样的问题的方法也很简单在头文件中的声明里面直接声明数组的大小报错就消失了。 todo [ ] 写算法的伪代码 [ ] 写算法的流程图 [ ] 状态转换图 [ ] 图形化界面 pseudocode.renderElement(document.getElementById(\"ParseProgram\")); pseudocode.renderElement(document.getElementById(\"Match\"));","categories":[{"name":"专业课","slug":"专业课","permalink":"https://ninoneumann.cn/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://ninoneumann.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"程序设计","slug":"程序设计","permalink":"https://ninoneumann.cn/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"单词-4-22","slug":"单词-4-22","date":"2022-04-23T00:29:35.000Z","updated":"2022-04-26T08:29:29.744Z","comments":true,"path":"2022/04/23/单词-4-22/","link":"","permalink":"https://ninoneumann.cn/2022/04/23/%E5%8D%95%E8%AF%8D-4-22/","excerpt":"","text":"4.22 单词 fluid adj 流动的 n 液体 wok n 铁锅 poke vt vi 戳 捅 poke you with a stick stab vt 刺 捅 be stabbed to death flap n 忧虑不安 get in a flap 陷入忧虑中 analytic adj 分析性的 an analytic mind 分析性思维 wicked adj 邪恶的 hierarchy n 等级制度 shepherd n 牧羊人 auction n 拍卖 tow vt 牵引 tow sth away 把……牵（拖）走 thrift n 节约 节俭 scout n 童子军 tub n 盆 comrade n 同志 朋友 （尤其指共患难） commute vi vt 上下班通勤 commute by car 开车上下班 furious adj 暴怒的 fury n 暴怒 狂怒 quiver vi 颤抖 哆嗦 her voice quivered quiver with excitement 激动地颤抖 hip n 臀部 doze vi 打瞌睡 doze off 打瞌睡 nun n 修女 尼姑 pub n 酒吧 酒馆 token n 代币 grope vi 摸索，寻找 grope around in the dark 在黑暗中摸索 vigorously adv 蓬勃地 rigorous adj 严密的 精确的 wretched adj 恶劣的 可怜的 难受的 the wretched place 那个倒霉的地方 a wretched life inventory n 储备 count the inventory 清点库存 appliance n 电器装置 ==infrared== adj 红外线的 ==splash== n 引人注目的效果 make a splash 引起关注 引起轰动 proficiency n 熟练精通 fellowship n 友谊 交情 n 研究生奖学金 thermometer n 温度计 torment n 折磨 in torment 在痛苦中 epoch n 时代 纪元 a new epoch hardy adj 能吃苦耐劳的 （植物）耐寒的 harden vi vt 变硬 使更坚定 sole adj 唯一的，仅有的 obsolete adj 淘汰的，废弃的，过时的。 apt adj 有……倾向的 apt to be careless 常常粗心大意 prototype n 原型 雏形 典型 test a prototype 测试原型机 presume vi vt 推测 猜测 i presume so 我想是吧 rake n 耙子 vt vi 耙 梳理 rake leaves into a pile 把落叶耙成一堆 giggle vt vi 咯咯傻笑 n 傻笑 ~ about bureau n 局 司 处 署 the federal bureau of inverstigation 联邦调查局 transition n 转变 a ~ from sth to sth evaporate vi vt 蒸发 vi 逐渐消失 evaporate quickly clash n 冲突 分歧 gasp vi vt 倒吸一口气 gasp with sth 因为……倒吸一口气 gasp in horror 吓得倒吸气 canoe n 独木舟 paddle a canoe 划独木舟 pitch n 球场 沥青 a football pitch 足球场 high pitch 高音 legacy n 遗产 adj （计算机系统等）已停止更新 ==whatsoever== adv 丝毫 任何 have no idea whatsoever 一无所知 deprive v 剥夺 retrieve v 取回 retrieve sth from somewhere vegetation n 植被 breakdown n 故障 ； 破裂 ； 精神崩溃；明细 expedition n 远征 探险队 短途旅行 ditch vt 丢弃，抛弃 ditch a plan 放弃计划 vicinity n 周围地区 in the immediate vicinity trees block the view in the immediate vicinity 树挡住了附近的景色 gum n 口香糖 牙龈 牙床 chew gum 嚼口香糖 gum ==disease== inlet n 水湾 congnitive adj 认知的 petition n 请愿书 申诉书 sign a petition 签请愿书","categories":[{"name":"每日英语单词","slug":"每日英语单词","permalink":"https://ninoneumann.cn/categories/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"英语","slug":"英语","permalink":"https://ninoneumann.cn/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"单词","slug":"单词","permalink":"https://ninoneumann.cn/tags/%E5%8D%95%E8%AF%8D/"}]},{"title":"Head-of-a-Gang-PAT-30-scores","slug":"Head-of-a-Gang-PAT-30-scores","date":"2022-04-22T02:52:54.000Z","updated":"2022-04-26T08:30:24.172Z","comments":true,"path":"2022/04/22/Head-of-a-Gang-PAT-30-scores/","link":"","permalink":"https://ninoneumann.cn/2022/04/22/Head-of-a-Gang-PAT-30-scores/","excerpt":"","text":"查看更新记录 2022-4-22开始编写 重构解题过程 吐槽：我真菜 哭。。 Head-of-a-Gang-PAT-30-scores 题目详情 - 1034 Head of a Gang (30 分) (pintia.cn) tips: 这道题目除了使用并查集来解决之外还可以使用dfs来做，基本的大题思路是求图的连通分量…… problem-description： One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads. Input Specification: Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format: 1Name1 Name2 Time where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes. Output Specification: For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads. Sample Input 1: 123456789108 59AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10 Sample Output 1: 12342AAA 3GGG 3 Sample Input 1: 12345678910118 70AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10 Sample Output 1: 120 思路： 时间复杂度分析： the first line contains two positive numbers N and K (both less than or equal to 1000) 输入的数据大小不大所以理论上不是什么太复杂的算法的话一般应该不会超时，我也没有在意。 带权重的并查集。 1、对于name到集合之间的映射关系的实现： 可以使用map直接构造集合map&lt;string, string&gt; 构成 父子之间的关系 也可以构造一个int -&gt; string 以及 string -&gt; int之间的转换关系 【相当于一个映射函数 【当然也可以像下面这样的实现【参考柳神的转换方法【就是用两个map构造转换关系】】】】 123456789101112131415....#include&lt;map&gt;....map&lt;string, int&gt; sti;map&lt;int, string&gt; its;int idx = 1;int stoifunc(string s)&#123; if(sti[s]==0)&#123; sti[s] = idx; its[idx] = s; return idx++; &#125;else return sti[s];&#125; 2、对于最后信息的收集和整理： 我需要记录的信息： 每个人的通话时间 value 这个也就是带权并查集的权值。 每个&quot;gang&quot;的人数 (最后结果的筛选条件之一) 每个&quot;gang&quot;的总通话时间 (最后结果的筛选条件之一) 满足条件的gang的个数。 遇到的一些困难： 当我对并查集进行find和merge的时候发现 如果让每个集合的父亲节点是权值最大的那一个节点能够让题目更加简洁，节省一些时间。 注意以下的代码是一个抽象的说明 并不是说这一题的set集合就是 int数组！！一定要在一定的理解上去观看！ 并查集的原来find函数： 123456789101112// 假设 原来集合是简单的int[] 集合 假设总集合 是int set[]// 递归式写法int find(int p)&#123; if(p!=set[p])set[p] = find(set[p]); return set[p];&#125;// 循环式写法int find(int p)&#123; while(p!=set[p])p = set[p]; return p;&#125; 当find函数检查当前字节点的权值&lt;父节点的权值的时候find函数就将父子节点对换 父节点变为子节点 子节点成为父节点，这样就能让每一个集合中【最后的根节点】父节点是权值最大的那一个。 1234567891011// 对循环式find函数进行一点小小的改动int find(int p)&#123; int t = p; // 用t 来暂时记录子节点 while(p!=set[p])p = set[p]; if(value[t]&gt;value[p])&#123; set[s] = t; set[t] = t; return t; &#125; return s;&#125; 为了维护每个集合的根节点所以也需要对merge做改动 1234567891011void merge(int p,int q)&#123; int fp = find(p); int fq = find(q); if(fp==fq)return ; if(value(fp)&gt;value(fq))&#123; set[fq] = fp; &#125;else&#123; set[fp] = fq; &#125; return;&#125; 题解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;map&lt;string, int&gt; value,member,total,ans;map&lt;string, string&gt; set;string find(string s)&#123; string t = s; while(s!=set[s])s = set[s]; if(value[s]&lt;value[t])&#123; set[s] = t; set[t] = t; return t; &#125; return s;&#125;void merge(string p,string q)&#123; string fq = find(q); string fp = find(p); if(value[fq]&gt;value[fp])&#123; set[fp] = fq; &#125;else&#123; set[fq] = fp; &#125; &#125;int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; while(n--)&#123; string a,b; int c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; value[a]+=c; value[b]+=c; if(set.find(a)==set.end())set[a] = a; // 初始化 if(set.find(b)==set.end())set[b] = b; merge(a,b); &#125; for(auto it:set)&#123; ++member[find(it.first)]; total[find(it.first)]+=value[it.first];// cout&lt;&lt;it.first&lt;&lt;&quot; &quot;&lt;&lt;value[it.first]&lt;&lt;&quot; father &quot;&lt;&lt;find(it.first)&lt;&lt;&quot; &quot;&lt;&lt;endl; &#125; for(auto it:member)&#123; if(total[it.first]/2&gt;k &amp;&amp; it.second&gt;2)&#123; ans[it.first] = it.second; &#125; &#125; cout&lt;&lt;ans.size()&lt;&lt;endl; for(auto it:ans)&#123; cout&lt;&lt;it.first&lt;&lt;&quot; &quot;&lt;&lt;it.second&lt;&lt;endl; &#125;&#125; 为什么这里的条件是total&gt;2k 一个简单的表述就是 total其实是将一个集合中所有的节点通话时间都加在一起了，但是题目中给出的 the total time length of all the phone calls其实是算和这个集合有关的phone call 的总时长 也就是这个k其实将两个人之间的通话时长看做一次phone call 而我这边的total 算的是每个人的 call ，而一次phone call 的对象有两个人 所以total是total phone call 的两倍。","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/categories/PAT/"}],"tags":[{"name":"PAT-30-scores","slug":"PAT-30-scores","permalink":"https://ninoneumann.cn/tags/PAT-30-scores/"},{"name":"algorithm","slug":"algorithm","permalink":"https://ninoneumann.cn/tags/algorithm/"},{"name":"并查集","slug":"并查集","permalink":"https://ninoneumann.cn/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"单词-4-21","slug":"单词-4-21","date":"2022-04-21T15:04:16.000Z","updated":"2022-04-26T08:29:27.576Z","comments":true,"path":"2022/04/21/单词-4-21/","link":"","permalink":"https://ninoneumann.cn/2022/04/21/%E5%8D%95%E8%AF%8D-4-21/","excerpt":"","text":"4.21 单词 rosy adj 红润的 rouse vt 唤醒 叫醒 beforehand adv 事先 预先 tell me beforehand tow days beforehand documentary adj 文献的 n 纪录片 avail vt vi 有用 有帮助 利用 My dear young lady, a show of temper will avail you nothing. bronze n 青铜色 青铜 青铜制品 mercury n 水银 intercourse n 性交 sexual intercourse 性交 aerial adj 航空的 aerial photography 航拍 spectacular adj 壮观的 盛大的 a spectacular view intact adj 完整无缺的，未受到损伤的。 remain intact miracle n 奇迹 slit n 缝隙 切口 closet n 壁橱 储藏室 invaluable adj 非常宝贵的 invaluable information turnover n 人员流动率 staff turnover electrician n 电工 hazard n 危险，隐患 harassment n 骚扰，侵扰 sexual harassment 性骚扰 interference n 干涉 介入 interference in sth 对……的干涉，对……的介入 intermediate adj 中级的 an intermediate course 中级课程 prescribe vt 开（药 处方） doctors prescribe too many pills prescribe medicine apparatus n 器械，仪器 breathing apparatus 呼吸装备 landlady n 女房东 女店主 equator n 赤道 ignite vt vi 燃烧，使燃烧， vt 激起 引发 a material that ignites easily plague n 鼠疫 灾害 祸患 vt 困扰 折磨 be plagued by illnesses 受疾病所困扰。 racket n 喧哗 勒索 敲诈 球拍 rack n 支架 架子 rocket n 火箭 bloom vi 开花 绽放 精神焕发 bloom in spring cemetery n 墓地 公墓 an old cemetery 古老的墓地 marginal adj 微不足道的 边缘的 a marginal group 边缘群体 margin n 页边空白处 territory n 领地 领域 versus prep 以……为对手 he versus her 他对她 shady adj 背阴的 a shady place ==outset== n 开始 at the outset 在开始的时候 trench n 沟渠，战壕 海沟 trench warfare 阵地战 horizontal adj 水平的 testimony n 证词 口供 a sworn testimony 宣誓证词 give false testimony 做假证 inward adj 内心的 内在的 adv 向内心的 outskirts n 郊区 on the outskirts of York 在郊区 ammonia n 氨 氨水 pneumonia n 肺炎 die of pneumonia 死于肺炎 catch pneumonia 染上肺炎 tame vt 驯服 tame a lion 驯服一只狮子 majesty n 雄伟壮观，庄严 ，陛下 your majesty Her majesty the Queen 女王陛下 embark vi 从事 着手 开始 开始做 embark on sth 从事 着手 开始做 treason n 危害国家 ，叛国罪 commit treason 犯叛国罪 kidnap vt 劫持 precedent n 可援引的例子 a legal precedent 判例 set a precedent 成为先例 mechanism n 机械装置 方法 途径 机制 cordial adj 热情友好的 和蔼可亲的 a cordial relationship 友好的关系 steamer n 汽船 大轮船 蒸笼 蒸锅 hut n （简陋）小屋 feudal adj 封建的 封建制度的 fascinate vt vi 使着迷 迷住 embody vt 使具体化 体现 embody a spirit 体现一种精神 grease n 油脂 动物油脂 bacon grease 培根油脂","categories":[{"name":"每日英语单词","slug":"每日英语单词","permalink":"https://ninoneumann.cn/categories/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"英语","slug":"英语","permalink":"https://ninoneumann.cn/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"单词","slug":"单词","permalink":"https://ninoneumann.cn/tags/%E5%8D%95%E8%AF%8D/"}]},{"title":"并查集-模板","slug":"并查集-模板","date":"2022-04-21T06:04:06.000Z","updated":"2022-04-26T08:30:47.513Z","comments":true,"path":"2022/04/21/并查集-模板/","link":"","permalink":"https://ninoneumann.cn/2022/04/21/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"更新时间线 2022-4-221、添加带权并查集的介绍 以及 自己的理解2、添加带权并查集的相关题目2022-4-211、更新了并查集 的模板题2、两道很简单的ACWing 的训练题 相关信息引用&&来源 带权并查集_syddf_shadow的博客-CSDN博客_带权并查集(127条消息) 并查集 （模板）_辣是真滴牛啤的博客-CSDN博客_并查集模板 并查集的模板 什么是并查集 并查集：将不同分散的结点，通过某种关系将他们连接成一个森林 并查集分为3步： 1、并：给出两点关系，如果属于同一集合，进行merge 2、查：在合并时，需要先写出查，即找到该点的祖先点 3、集：merge后，将新加入的点的祖先点更新 基本并查集的模板 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;#define N 10000 // 定义并查集 元集合的大小 并查集可以是一个structint set[N];void init()&#123; for(int i = 0;i&lt;N;++i)set[i] = i;&#125;// 这里查方法这么写会导致 递归栈爆炸 更加优秀的操作是类似记忆化搜索 在搜索父亲的时候将所有的子节点的父亲信息更新int find(int q)&#123; if(set[q]==q)return q; return find(set[q]);&#125;void merge(int q,int p)&#123; int fq = find(q); int fp = find(p); // （有些题目） 在这里需要注意 merge的时候需要判断 两集合的父亲是否相同！ set[fq] = fp;&#125; 并查集find函数的注意点 这是find函数的路径压缩： set[i] 中存放的 12345// find函数的优化int find(int q)&#123; if(set[q]!=q) set[q] = find(set[q]); // 更新查找路径上的子节点的父亲节点 统一父亲节点信息 return set[q];&#125; 相关例题： 836. 合并集合 - AcWing题库 这一题主要是注意find函数 的优化问题 要是按照我第一个find 函数的写法肯定过不了！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define N 100010int a[N];void init()&#123; for(int i = 0;i&lt;N;++i)a[i] = i;&#125;int find(int i)&#123; if(a[i]==i)return i; return find(a[i]);&#125;void merge(int q,int p)&#123; int qf = find(q); int pf = find(p); a[qf] = pf;&#125;int main()&#123; init(); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 0;i&lt;m;++i)&#123; int d,b; char q; cin&gt;&gt;q&gt;&gt;d&gt;&gt;b; switch(q)&#123; case &#x27;M&#x27;: merge(d,b); break; case &#x27;Q&#x27;: if(find(d)==find(b))cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; break; &#125; &#125; return 0;&#125; 837. 连通块中点的数量 - AcWing题库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;// 对某些部分进行一点点魔改就可以了using namespace std;#define read(x) scanf(&quot;%d&quot;,&amp;x)const int N = 100010;int set[N];int number[N];void init()&#123; for(int i = 0;i&lt;N;++i)&#123; set[i] = i; number[i] = 1; &#125; &#125;int find(int q)&#123; if(set[q]!=q)&#123; set[q] = find(set[q]); &#125; return set[q];&#125;void merge(int q,int p)&#123; int fq = find(q); int fp = find(p); if(fq==fp)return; set[fp] = fq; // 魔改部分 number[fq]+=number[fp];&#125;// 对于询问 设置一个遍历函数int main()&#123; init(); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 0;i&lt;m;++i)&#123; int a,b; char c[2]; // cin&gt;&gt;c&gt;&gt;a&gt;&gt;b; scanf(&quot;%s %d %d&quot;,&amp;c,&amp;a,&amp;b); if(c[0]==&#x27;C&#x27;)merge(a,b); else if(c[1]==&#x27;1&#x27;) if(find(a)==find(b))cout&lt;&lt;&quot;Yes\\n&quot;; else cout&lt;&lt;&quot;No\\n&quot;; else cout&lt;&lt;number[find(a)]&lt;&lt;endl; &#125; return 0;&#125; 并查集的拓展：带权并查集 什么是带权并查集 一般的并查集主要记录节点之间的链接关系，而没有其他的具体的信息，仅仅代表某个节点与其父节点之间存在联系，它多用来判断图的连通性，如下图所示，这是一个并查集，其中箭头表示父子关系，可以看到这些边没有记录其他的任何信息。 而有的时候在这些边中添加一些额外的信息可以更好的处理需要解决的问题，在每条边中记录额外的信息的并查集就是带权并查集。 路径压缩 一个简单的理解：路径压缩是 对 find 函数的优化，减少了find函数查询父节点的时间开销。 直观上的理解就是下图 （和上面一张图进行对比）也就是 将远处的孩子和其根节点直接连接起来 路径压缩的代码 （其实上面说过了） 1234int find(int p)&#123; if(p!=set[p])set[p] = find(set[p]); return set[p];&#125; 直观上带权并查集是这样的: 可以看到它的每一条边都记录了每个节点到根节点的一个权值，这个权值该设为什么由具体的问题而定，一般都是两个节点之间的某一种相对的关系，但是考虑到权值就会有两个问题： 1、每个节点都记录的是与根节点之间的权值，那么==在Find的路径压缩过程中，权值也应该做相应的更新==，因为在路径压缩之前，每个节点都是与其父节点链接着，那个Value自然也是与其父节点之间的权值 2、在两个并查集==做合并的时候，权值也要做相应的更新==，因为两个并查集的根节点不同。 tips: 回头想了想 acwing 的第二道练习题 number数组不就是权值吗，只不过我们重点维护的不是每一个节点的权值，而是父节点的权值 【所以find函数并没有去对&quot;权值进行更新&quot;】 例题：PAT-1034 题目详情 - 1034 Head of a Gang (30 分) (pintia.cn) 基本思路就是 用map存储信息当做father集合 使用map做映射（柳神有dfs的做法【以后再说】） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;const int N = 1010;map&lt;string, int&gt; value,member,total,ans;map&lt;string, string&gt; set;string find(string s)&#123; string t = s; while(s!=set[s])s = set[s]; if(value[s]&lt;value[t])&#123; set[s] = t; set[t] = t; return t; &#125; return s;&#125;void merge(string p,string q)&#123; string fq = find(q); string fp = find(p); if(value[fq]&gt;value[fp])&#123; set[fp] = fq; &#125;else&#123; set[fq] = fp; &#125; &#125;int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; while(n--)&#123; string a,b; int c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; value[a]+=c; value[b]+=c; if(set.find(a)==set.end())set[a] = a; // 初始化 if(set.find(b)==set.end())set[b] = b; merge(a,b); &#125; for(auto it:set)&#123; ++member[find(it.first)]; total[find(it.first)]+=value[it.first];// cout&lt;&lt;it.first&lt;&lt;&quot; &quot;&lt;&lt;value[it.first]&lt;&lt;&quot; father &quot;&lt;&lt;find(it.first)&lt;&lt;&quot; &quot;&lt;&lt;endl; &#125; for(auto it:member)&#123; if(total[it.first]/2&gt;k &amp;&amp; it.second&gt;2)&#123; ans[it.first] = it.second; &#125; &#125; cout&lt;&lt;ans.size()&lt;&lt;endl; for(auto it:ans)&#123; cout&lt;&lt;it.first&lt;&lt;&quot; &quot;&lt;&lt;it.second&lt;&lt;endl; &#125;&#125; 240. 食物链 - AcWing题库 1","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/categories/PAT/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://ninoneumann.cn/tags/algorithm/"},{"name":"并查集","slug":"并查集","permalink":"https://ninoneumann.cn/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"PAT-20-scores","slug":"PAT-20-scores","permalink":"https://ninoneumann.cn/tags/PAT-20-scores/"}]},{"title":"The-Black-Hole-of-Numbers-PAT-20-scores","slug":"The-Black-Hole-of-Numbers-PAT-20-scores","date":"2022-04-21T02:17:28.000Z","updated":"2022-04-26T08:30:54.753Z","comments":true,"path":"2022/04/21/The-Black-Hole-of-Numbers-PAT-20-scores/","link":"","permalink":"https://ninoneumann.cn/2022/04/21/The-Black-Hole-of-Numbers-PAT-20-scores/","excerpt":"","text":"The-Black-Hole-of-Numbers-PAT-20-scores 题目链接 tips: 很简单的一道题目 用来学习一下基础库函数操作 problem-description： For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number 6174 – the black hole of 4-digit numbers. This number is named Kaprekar Constant. For example, start from 6767, we’ll get: 12345677766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 61747641 - 1467 = 6174... ... Input Specification: Each input file contains one test case which gives a positive integer N in the range (0,$$10^4$$). Output Specification: If all the 4 digits of N are the same, print in one line the equation N - N = 0000. Else print each step of calculation in a line until 6174 comes out as the difference. All the numbers must be printed as 4-digit numbers. Sample Input 1: 126767 Sample Output 1: 123457766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 6174 Sample Input 1: 122222 Sample Output 1: 122222 - 2222 = 0000 思路： 模拟题，主要需要认识到当 前一个数 减去后一个数 得到的result 不是一个四位数的时候需要补0 解答: 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt; using namespace std;// The-Black-Hole-of-Numbers-PAT-20-scores // 1069 The Black Hole of Numbers (20 分)// sort 默认是从小到大排列 // stoi to_string string.insert() bool cmp(char a,char b)&#123; return a&gt;b;&#125;int main()&#123; string s; cin&gt;&gt;s; s.insert(0,4-s.length(),&#x27;0&#x27;); do&#123; string a = s,b = s; sort(a.begin(),a.end(),cmp); sort(b.begin(),b.end()); s = to_string((int(stoi(a)-stoi(b)))); s.insert(0,4-s.length(),&#x27;0&#x27;); cout&lt;&lt;a&lt;&lt;&quot; - &quot;&lt;&lt;b&lt;&lt;&quot; = &quot;&lt;&lt;s&lt;&lt;endl; &#125;while(s!=&quot;6174&quot; &amp;&amp; s!=&quot;0000&quot;); return 0;&#125; 几个知识点： sort 排序默认升序 从小往大 stoi() 理论上来说要输入 #include&lt;string&gt; 但是我没输入 stoi 函数似乎不支持 c++ 11 以下的版本 stoi 函数可以用来做 string 类型到 数据类型的转换 1234int stoi (const string&amp; str, size_t* idx = 0, int base = 10);int stoi (const wstring&amp; str, size_t* idx = 0, int base = 10);// base 参数可以指定 转换的数据类型 2-10 进制// 第二个参数表明的从第idx 个位置往后作为转换的内容 On success, the function returns the converted integral number as an int value. to_string() 对to_string 特性的支持 也是在 2011版本之后的 to_string - C++ Reference (cplusplus.com) 12345678910// 还能说什么呢， 挺强大的string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val); string.insert() string::insert - C++ Reference (cplusplus.com) 这道题目主要使用的是fill功能。","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/categories/PAT/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://ninoneumann.cn/tags/algorithm/"},{"name":"PAT-20-scores","slug":"PAT-20-scores","permalink":"https://ninoneumann.cn/tags/PAT-20-scores/"}]},{"title":"单词-4-20","slug":"单词-4-20","date":"2022-04-20T14:17:34.000Z","updated":"2022-04-26T08:29:25.385Z","comments":true,"path":"2022/04/20/单词-4-20/","link":"","permalink":"https://ninoneumann.cn/2022/04/20/%E5%8D%95%E8%AF%8D-4-20/","excerpt":"","text":"4.20 单词 gamble vi vt 赌博 gamble your fortune on cards. remnant n 残余部分 food remnants veto vt 不同意 veto a plan foam n 泡沫橡胶 oar n 船桨 meadow n 草甸，牧场 stalk vi 怒气冲冲地走 sovereign adj 有主权的，至高无上的 a sovereign state intermittent adj 间歇的，断断续续的 intensity n 强烈 剧烈 mutter vt vi 小声嘀咕，小声抱怨 he mutter sth i could not hear. mutter to yourself 独自抱怨 mutter about sth 小声抱怨某事。 handicap n 生理缺陷 障碍 阻碍 mischief n恶作剧. transcend vt 超出 it transcends age, culture, and language nonetheless adv 尽管如此 it was a barren region, but beautiful nonetheless. ruthless adj 无情的，残酷的 echo n 回声 回音 a faint echo 微弱的回声. vt vi echo with sth 回荡着。 console vt 安慰 console sb with sth 用……来安慰某人. console onself that…… 自我安慰…… n 控制台 vanity n 自负，虚荣 vain adj 徒劳的，自负的，虚荣的 vicious adj残暴的，凶狠的 he looks vicious revelation n 被揭示的真相。 rib n 肋骨 crisp n 炸薯片 vi vt 变脆 nurture vt 培养 养育 n 培养 养育 memo n 备忘录 messenger n 送信人 message n 消息 信息 pinch vt 掐 捏 pinch your arm priest n 牧师 神职人员 a Taoist priest trolley n 购物车 n 有轨电车 a trolley car 电车 necessitate vt 使成为必须 necessitate a change 需要作出改变 necessitate doing sth 有必要做某事 sincere adj 由衷的，衷心的 compartment n 火车分隔箱 a first-class compartment courtesy adj 有礼貌的 preposition n 前置 hypocrisy n 伪善，虚伪 canvas n 画布 dedicate vt dedicate sth to doing / sth slaughter vt 屠杀，杀戮 groan vi 抱怨 mutter moan and groan 唉声叹气 wholesome adj 有益健康的 senator n 参议员 senate n 参议院 blackmail n 敲诈勒索信 removal n 移开 移走 remove chap n 伙计 老兄 buddy neutral adj 中立的 orchard n 果园 an apple orchard grumble vi vt 嘟囔 发牢骚 mutter groan scramble vi 爬行 scramble up the cliff velocity n 速度 ponder vi vt 沉思 考虑 ponder a question ponder on sth 沉思 琢磨 champagne n 香槟 brisk adj 轻快的 干练的 麻利的 she speaks in a brisk tone 她讲话自信干练 revolt n 反叛 rebellion vi revolt against a government stun vt 使震惊 i am completely stunned by the information arrogant adj 傲慢的，自大的 proud and arrogant solo n 独唱 terrific adj 极好的 terrible adj 可怕的，糟糕的，十足的 gracious adj 慈祥和蔼的a gracious smile 一个慈祥的笑容 stake n 重大利益 at stake 有风险 处于危机关头 vt 以…… 打赌 stake a claim 公开宣布自己的拥有权 ==scrutiny== n 彻底审查 仔细检查 repression n 压制 镇压 the government repression 政府镇压 plough n 犁 vt vi 犁（田） plough through sth 埋头苦干 艰难地前行 pistol n 手枪 soar vi 猛增 the price soared 。 cardinal n 红衣主教 adj 基本的 极重要的 a cardinal rule 基本原则 finite adj 有限的 有尽的 a finite amount of time 有限时间 interior n 内部 adj 内部的 prospective adj 潜在的 可能发生的 预期的 a prospective client 潜在客户 hollow adj 空心的 a hollow tree maiden n 少女 姑娘","categories":[{"name":"每日英语单词","slug":"每日英语单词","permalink":"https://ninoneumann.cn/categories/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"英语","slug":"英语","permalink":"https://ninoneumann.cn/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"单词","slug":"单词","permalink":"https://ninoneumann.cn/tags/%E5%8D%95%E8%AF%8D/"}]},{"title":"The-Dominant-Color-PAT-20-scores","slug":"The-Dominant-Color-PAT-20-scores","date":"2022-04-20T01:39:05.000Z","updated":"2022-04-26T08:30:51.969Z","comments":true,"path":"2022/04/20/The-Dominant-Color-PAT-20-scores/","link":"","permalink":"https://ninoneumann.cn/2022/04/20/The-Dominant-Color-PAT-20-scores/","excerpt":"","text":"The-Dominant-Color-PAT-20-scores problem-description: Behind the scenes in the computer’s memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. A strictly dominant color takes more than half of the total area. Now given an image of resolution M by N (for example, 800×600), you are supposed to point out the strictly dominant color. Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive numbers: M (≤800) and N (≤600) which are the resolutions of the image. Then N lines follow, each contains M digital colors in the range [0,$$2^{24}$$). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space. Output Specification: For each test case, simply print the dominant color in a line. Sample Input: 12345 30 0 255 16777215 2424 24 0 0 2424 0 24 24 24 Sample Output: 124 读题： 条件限制： ​ dominant color： the color with the largest proportional area is called the dominant color. ​ a strictly dominant color: A strictly dominant color takes more than half of the total area. 目标： ​ you are supposed to ==point out the strictly dominant color==. ​ 找出占图像大小多于一半的颜色 思路： 小问题： 如果没有strictly dominant color 该怎么办？ Output 好像就说了输出dominant color 就可以了。 纯暴力： 枚举 将所有遇到的颜色存储在一个数据结构中并对其进行排序 最后找出最大的数 时间复杂度： sort 快排的时间复杂度为$$O(n\\log(n))$$ 遍历数组的时间复杂度$$O(nm)$$ 考虑到数据范围$$M\\le 800 \\ \\ N\\le 600$$ 应该是可接受的。 空间复杂度： 最坏的情况可能要开 $$2\\times2^{24}$$个int (按照键值对的方法存储) 限制空间 $$2^{6}\\times 2^{30}$$ 理论上来说是够了 我的一开始的想法： 用一个map存储键值对 键：出现的颜色 值：出现的次数 tips: 好像挺简单的 emmmm :sweat: 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;// 1054 The Dominant Color (20 分)map&lt;int,int&gt;mp;int m,n;int dc,cnt;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 0;i&lt;n;++i)&#123; for(int j = 0;j&lt;m;++j)&#123; int k; cin&gt;&gt;k; mp[k]++; if(cnt&lt;mp[k])&#123; cnt = mp[k]; dc = k; &#125; &#125; &#125; cout&lt;&lt;dc&lt;&lt;endl; return 0;&#125; 其他： emm 行吧，这题就纯STL送分题。","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/categories/PAT/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://ninoneumann.cn/tags/algorithm/"},{"name":"PAT-20-scores","slug":"PAT-20-scores","permalink":"https://ninoneumann.cn/tags/PAT-20-scores/"}]},{"title":"高等数学-Skill-points","slug":"高等数学-Skill-points","date":"2022-04-19T14:11:58.000Z","updated":"2022-06-17T12:09:54.782Z","comments":true,"path":"2022/04/19/高等数学-Skill-points/","link":"","permalink":"https://ninoneumann.cn/2022/04/19/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-Skill-points/","excerpt":"","text":"更新时间线 2022-6-17添加驻点、拐点、极值点的定义添加连续、可导（一元函数）的概念、定义2022-6-14只不过是重头再来！！关于函数极限的问题2022-6-11只不过是重头再来！！关于函数的拐点问题2022-5-27只不过是重头再来！！添加一个有关于极限的典型例题2022-5-26多元函数微分学2022-5-11查漏补天如何求斜渐进线待定系数法分解函数 将分母分子的冗余项分开2022-5-8查漏补天添加一点新东西 三角函数的一些公式终于到第二章了2022-5-4查漏补天添加极限部分的提高做法 对于变上限的积分函数的求解极限的某种题型使用洛必达求解函数中的系数以及分子的最小阶数的时候目标是凑出一个分子分母都不为0 的状态对于给出一个极限求解函数中的某些系数的题目……对于周期函数的求积分一定要注意被积函数的周期性！！！需要使用夹逼定律才能计算出来的极限值和极限相关的证明题目2022-5-3查漏补天添加极限部分的一个例题添加一个计算某一类极限的一个注意点对于$$(\\infty)^{0}$$的问题 的 求解的方法对于抽象复合函数的极限求解的问题需要看复合函数的最大差值添加一个求解$$(1)^{\\infty}$$型的题目三角函数的加减今天把极限部分的复习+提高完成复习简单题目昨晚之后总结： 泰勒是个好东西！2022-4-29更新第一章求极限部分的一些内容查漏补天介值定理添加cos函数 和 sin函数的定积分公式修正$$\\arcsin$$ 函数的麦克劳林公式间断点部分再看看。2022-4-24更新第一章求极限部分的一些内容添加了复合函数的泰勒展开部分添加了有关变限函数积分的一个知识点2022-4-20更新第一章求极限部分的一些内容 高等数学-skill-points 前几个月没有好好搞，现在好好搞一搞，重新来一遍吧，争取一个星期再过一遍基础。:cry: 整理的来源 汤家凤1800 函数、极限、连续部分。 驻点、极值点、拐点的定义 极值点、驻点和拐点区别 - 知乎 (zhihu.com) 一定记住驻点极值点拐点之间的关系 定义： 驻点： 一阶导函数为零的点，多元函数的驻点是一阶偏导数都为0的点 极值点： ![[Pasted image 20220617194443.png]] 拐点： 函数凹凸性改变的点 极值点判定的三个充分条件 极值的三个充分条件及其应用 - 知乎 (zhihu.com) 驻点不一定是极值点 极值点不一定是拐点 （不可导的点例如$$|x|$$在x = 0处有极值点但是极值点不是驻点） 常见公式的麦克劳林公式。！！！ ex=∑n=0xnn!sin⁡(x)=∑n=0(−1)n(2n+1)!x2n+1cos⁡(x)=∑n=0(−1)n(2n)!x2ntan⁡(x)=x+13x3+o(x3)arcsin⁡(x)=x+16x3+o(x3)arcsin⁡(x)=x+(2k−1)!!2k+1x2k+1arctan⁡(x)=x−13x3+o(x3)(1+x)α=1+∑n=1α(α−1)(α−2)...(α−n+1)n!xnln⁡(1+x)=∑n=0(−1)nn+1xn+1ax=1+∑i=1n[ln(a)]ii!xie^{x} = \\sum_{n = 0}\\frac{x^{n}}{n!} \\\\ \\sin(x) = \\sum_{n=0}\\frac{(-1)^{n}}{(2n+1)!}x^{2n+1} \\\\ \\cos(x) = \\sum_{n=0}\\frac{(-1)^{n}}{(2n)!}x^{2n} \\\\ \\tan(x) = x+\\frac{1}{3}x^{3}+o(x^{3}) \\\\ \\arcsin(x) = x+\\frac{1}{6}x^{3}+o(x^{3}) \\\\ \\arcsin(x) = x+\\frac{(2k-1)!!}{2k+1}x^{2k+1} \\\\ \\arctan(x) = x-\\frac{1}{3}x^{3}+o(x^{3}) \\\\ (1+x)^{\\alpha} = 1 + \\sum_{n=1}\\frac{\\alpha(\\alpha-1)(\\alpha-2)...(\\alpha-n+1)}{n!}x^{n} \\\\ \\ln(1+x) = \\sum_{n=0}\\frac{(-1)^n}{n+1}x^{n+1} \\\\ a^{x} = 1+\\sum^{n}_{i = 1}\\frac{[ln(a)]^{i}}{i!}x^{i} ex=n=0∑​n!xn​sin(x)=n=0∑​(2n+1)!(−1)n​x2n+1cos(x)=n=0∑​(2n)!(−1)n​x2ntan(x)=x+31​x3+o(x3)arcsin(x)=x+61​x3+o(x3)arcsin(x)=x+2k+1(2k−1)!!​x2k+1arctan(x)=x−31​x3+o(x3)(1+x)α=1+n=1∑​n!α(α−1)(α−2)...(α−n+1)​xnln(1+x)=n=0∑​n+1(−1)n​xn+1ax=1+i=1∑n​i![ln(a)]i​xi 和差化积&amp;积化和差 极限的运算 最好能熟练证明 关于除法的运算证明需要注意一下 函数极限可以由以下的五个类型组成 极限为常数 极限唯一 局部保号性 局部有界性 等式脱帽 ![[Pasted image 20220614103707.png]] 关于局部有界性 ![[Pasted image 20220614101126.png]] ![[Pasted image 20220614102705.png]] 局部有界性就是在对开区间的两端判断是否有极限从而判断开区间的连续函数是否有界 闭区间的连续函数则不需要这个判断。 关于局部保号性(不等式脱帽带帽) 脱帽法 严格不等（小于 大于） 带帽法 并不严格 常见的等价无穷小！！！ tips: 在做题的时候遇到分子分母等价无穷小的时候 需要展开 判断两个函数在同一点展开的无穷小的阶数，以及判断两个无穷小之间的关系 要特别注意无穷小判断的时候看的是阶数最小的那一项！ 在判断两个函数无穷小的阶数的时候，如果遇到了积分变限函数要尤其注意最后的阶数的判定 复合函数的泰勒展开！ 关于这个部分可以看这个视频去理解以下复合函数的泰勒展开以及相关的例题：强化66题（2）复合函数泰勒公式展开_哔哩哔哩_bilibili 如果出现无穷比无穷型的极限 记得使用洛必达！ 洛必达使用的条件 tips: 有时候洛必达如果一次没看出来的话可以多洛几次。 变限积分函数中，当积分上下限逼近，被积函数也同样逼近。 详情参考1800 p75 第一个选择题 当求极限的式子中出现 复合的公式该怎么办？ 例如：lim⁡x→0sin⁡(tan⁡(x))−xx3例如： \\lim_{x\\rightarrow 0}\\frac{\\sin(\\tan(x))-x}{x^{3}} 例如：x→0lim​x3sin(tan(x))−x​ tips: 用泰勒展开的角度去解这种题目 求解趋向无穷时候的极限 lim⁡x→∞(1+1x)x2ex\\lim_{x\\rightarrow\\infin}\\frac{(1+\\frac{1}{x})^{x^{2}}}{e^{x}} x→∞lim​ex(1+x1​)x2​ 对于上面的题目 分子化为e的指数形式然后使用麦克劳林公式展开的时候一定要记住将不为0的阶数展开全面 info： 分子$$(1+\\frac{1}{x})^{x^{2}}$$ 进行指数化然后麦克劳林展开$$x^{2}(\\frac{1}{x}-\\frac{1}{2x^{2}}+o(\\frac{1}{x^{2}}))$$接下来怎么做你懂的。 1的无穷次方 的题目 lim⁡x→0(a1x+a2x……anxn)1x (ai&gt;0)\\lim_{x\\rightarrow 0}(\\frac{a^{x}_{1}+a^{x}_{2}……a^{x}_{n}}{n})^{\\frac{1}{x}} \\ (a_{i}&gt;0) x→0lim​(na1x​+a2x​……anx​​)x1​ (ai​&gt;0) 这一题是有关于ax幂函数的麦克劳林展开求极限a^{x}幂函数的麦克劳林展开求极限ax幂函数的麦克劳林展开求极限 lim⁡x→0ax−1x\\lim_{x\\rightarrow 0}\\frac{a^{x}-1}{x} x→0lim​xax−1​ 一个抽象复合函数求解极限的问题 1800、p9、91800 、p9、 9 1800、p9、9 变上限函数的求解常系数 求a、b、clim⁡x→0ax2+1x4+b∫0xe−t2dtx5=c求 a、b、c\\\\ \\lim_{x\\rightarrow0}\\frac{a}{x^{2}}+ \\frac{1}{x^{4}}+ \\frac{b\\int^{x}_{0}e^{-t^{2}}dt}{x^{5}}=c 求a、b、cx→0lim​x2a​+x41​+x5b∫0x​e−t2dt​=c 这题目可以将$$\\frac{b\\int^{x}_{0}e^{-t^{2}}dt}{x^{5}}$$这个积分函数的被积函数部分抽离出来并进行麦克劳林展开$$e^{-t^{2}}=1+(-t^{2})+\\frac{1}{2!}(-t^{2})^{2}+\\frac{1}{3!}(-t^{2})^{3}+o((-t^{2})^{3})$$ warning: 由于这里的被积函数是需要积分的所以可以开到$$(-t^{2})^{2}$$就停下 warning: 如果使用洛必达法则需要保证在洛必达的过程中 分子分母都是0 660 p157 437题 438题 对于给出一个极限求解函数中的某些系数的题目 总的思路是将分子分母！对阶！ 方法有洛必达 或者 分子泰勒展开凑阶数 与分母对阶。 使用夹逼准则求出极限值的方法 lim⁡n→∞∑i=12neinn+1i\\lim_{n\\rightarrow \\infty}\\sum_{i=1}^{2n}\\frac{e^{\\frac{i}{n}}}{n+\\frac{1}{i}} n→∞lim​i=1∑2n​n+i1​eni​​ 上面的这一题是对分母整体进行缩放 lim⁡n→∞∑i=1i=n1n+i2+1n\\lim_{n\\rightarrow\\infty}\\sum_{i=1}^{i=n}\\frac{1}{n+\\frac{i^2+1}{n}} n→∞lim​i=1∑i=n​n+ni2+1​1​ 这里值得注意的一点是对分母进行扩大的时候会相较于原式多出来的两项 origin+1n+n+1n−1n+1norigin+\\frac{1}{n+\\frac{n+1}{n}}-\\frac{1}{n+\\frac{1}{n}} origin+n+nn+1​1​−n+n1​1​ 与极限相关的证明题 单调 有界 大于0 或者小于0 求极限 如果考难的话应该会结合很多的判断和式大小的一些知识点 算数平均数 &amp; 几何平均数 &amp; 调和平均数 &amp; 均方平均数 HnH_{n}\\\\ Hn​ 间断点。 第二章 泰勒展开的唯一性【660 p163 455题】 遇到的问题1： f(x)=lim⁡n→∞1+x1+x2n 求f(x)的间断点【如果有的话】f(x) = \\lim_{n\\rightarrow \\infin}\\frac{1+x}{1+x^{2n}} \\ \\ 求f(x)的间断点【如果有的话】 f(x)=n→∞lim​1+x2n1+x​ 求f(x)的间断点【如果有的话】 注意判断x在不同的取值的时候 极限的表达式【就是要熟悉$$a^{x}$$在a取不同的值的时候对应的函数的一些基本性质】 求斜渐近线 先求斜率然后求y轴偏移 待定系数法分解 -&gt; 有理真分式分解定理 660 466题 [高数]不定积分待定系数法的基础：有理真分式分解定理 - 荒原之梦 (zhaokaifeng.com)了解入门篇 多元函数微分学 掌握 可微 可偏导 连续 连续可偏导 多元函数求极限 多元函数求极限方法总结 - 知乎 (zhihu.com) 证明多元函数趋近某一个点极限存在 通过多元函数极限的定义 + 对原函数的适当缩放 找函数中的有界函数进行缩放 利用夹逼准则进行缩放 证明多元函数趋近某一个点极限不存在 找直线系 找其他的曲线公式 求函数拐点 对于具体的函数：现在遇到的求函数的拐点问题多半是使用二阶导数直接求解 (二阶导数=0的点是拐点) 积分 对于变限积分有时候可以省略一些无关值 注意变换！ ![[Pasted image 20220617200952.png]]","categories":[{"name":"数学","slug":"数学","permalink":"https://ninoneumann.cn/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"技能点","slug":"技能点","permalink":"https://ninoneumann.cn/tags/%E6%8A%80%E8%83%BD%E7%82%B9/"},{"name":"高等数学","slug":"高等数学","permalink":"https://ninoneumann.cn/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"快速幂算法初步","slug":"快速幂算法初步","date":"2022-04-19T08:34:43.000Z","updated":"2022-04-26T07:33:42.648Z","comments":true,"path":"2022/04/19/快速幂算法初步/","link":"","permalink":"https://ninoneumann.cn/2022/04/19/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/","excerpt":"","text":"更新时间线 2022-4-26添加了关于矩阵快速幂问题的了解 以及 自己的理解斐波那契矩阵快速幂解决思路POJ 3050POJ 3150有待进一步解决2022-4-19更新了快速幂的算法初步两道很简单的ACWing 的训练题初步涉及矩阵快速幂问题 快速幂算法初步 什么是快速幂 快速幂（Exponentiation by squaring，平方求幂）是一种简单而有效的小算法，它可以以O(log(n))O(log(n))O(log(n))的时间复杂度计算乘方。 在对某个底数aaa求幂的时候我们遇到的问题是： 幂运算的速度如何再次优化并使得结果好于O(n)O(n)O(n) 。 当指数过大的时候 数据范围超过机器最大可以表示的范围。 取模的运算法则 当数据范围过大的时候有些题目需要让我们取某一个数的模。于是下面引入 加、减、乘、指数运算的时候的模运算法则 (a+b)%d=(a%d+b%d)%d(a−b)%d=(a%d−b%d)%d(a∗b)%d=(a%d∗b%d)%dab%d=(a%d)b%d(a+b)\\%d = (a\\% d+b\\%d)\\%d \\\\ (a-b)\\%d = (a\\% d-b\\%d)\\%d \\\\ (a*b)\\%d = (a\\% d*b\\%d)\\%d \\\\ a^{b}\\%d = (a\\% d)^{b}\\%d \\\\ (a+b)%d=(a%d+b%d)%d(a−b)%d=(a%d−b%d)%d(a∗b)%d=(a%d∗b%d)%dab%d=(a%d)b%d 如何加速运算 二分思想： 例如: 原本求$$3^{10}$$ 可以写成$$9^{5}$$==$$81^{2}9$$ 写出一个递归方程 an={an2an2,n is even not 0an−1a,n is odd1,n=0a^{n} = \\begin{cases} a^{\\frac{n}{2}}a^{\\frac{n}{2}}, &amp; n\\ is\\ even \\ not \\ 0\\\\ a^{n-1}a, &amp; n \\ is \\ odd \\\\ 1, &amp; n=0 \\end{cases} an=⎩⎨⎧​a2n​a2n​,an−1a,1,​n is even not 0n is oddn=0​ 简单快速幂实现的两种方式 递归快速幂 按照上面的递归方程很容易写出递归算法 1234567891011// 快速幂// 递归快速幂 在 int范围内的int exponentiation_by_squaring(int a,int b)&#123; if(b==0)&#123; return 1; &#125;else if(b%2==0)&#123; return exponentiation_by_squaring(a*a,b/2); &#125;else&#123; return a*exponentiation_by_squaring(a,b-1); &#125;&#125; 鉴于上面所说，由于指数过大的时候数据范围超出表示，所以我们需要对结果进行取模运算，于是对上述的代码进行小小的改进就可以得到如下的代码： 12345678910111213// 递归快速幂加上取模运算int exponentiation_by_squaring(int a,int b)&#123; if(b==0)&#123; return 1; &#125;else if(b%2==0)&#123; a %= N; return exponentiation_by_squaring(a*a,b/2)%N; &#125;else&#123; a %= N; return a*exponentiation_by_squaring(a,b-1)%N; &#125;&#125; tips: 需要特别注意，请看清楚数据的表示范围如果，需要运算的数据过大 这里的参数类型以及函数范围类型设置为int是不合理的需要设置成 long long 记住 232=42949672962^{32}=4294967296232=4294967296 非递归快速幂 理解了递归快速幂的算法过程之后非递归的快速幂算法实现需要结合一点位运算的思想 例如以下使用7为底数求7107^{10}710 将指数10 换成二进制 数(1010)2(1010)_{2}(1010)2​在循环中对n循环右移并对其最后一位进行与判断这样就能实现快速幂算法 非递归快速幂相较于递归快速幂的好处就是减少了对递归栈的空间占用。 1234567891011// 快速幂的非递归写法 int exponentiation_by_squaring(int a,int b)&#123; int res = 1; while(b)&#123; if(b&amp;1) res *=a; a*=a; b&gt;&gt;=1; &#125; return res;&#125; 快速幂的典型例题 89. a^b - AcWing题库 873. 欧拉函数 - AcWing题库 快速幂拓展 快速幂的一个通用的模板 12345678910111213template &lt;typename T&gt;T exponentiation_by_squaring(T a, ll n)&#123; T ans = 1; // 赋值为乘法单位元，可能要根据构造函数修改 while (n) &#123; if (n &amp; 1) ans = ans * a; // 不用自乘是因为需要对*进行重载 n &gt;&gt;= 1; a = a * a; &#125; return ans;&#125; 矩阵快速幂 举证快速幂前置知识：矩阵乘法 A⋅B=Ddij=∑k=1naikbkjA\\cdot B = D \\\\ d_{ij} = \\sum_{k=1}^{n}a_{ik}b_{kj} A⋅B=Ddij​=k=1∑n​aik​bkj​ C++: 这里的矩阵使用一个二维数组表示 123456789101112// a b 都为方阵并且 是 n void multi_matrix(int a[][N],int b[][N],int n)&#123; for(int i = 0;i&lt;n;++i)&#123; for(int j = 0;j&lt;n;++j)&#123; for(int k = 0;k&lt;n;++k)&#123; c[i][j] = a[i][k]*b[k][j]; &#125; &#125; &#125; &#125; tips: 这里的矩阵乘积的时间复杂度是 O(n3)O(n^{3})O(n3) 但是有更快的算法 关于最简单的举证快速幂 只要将快速幂算法中的底数换成矩阵就可以了 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;// 矩阵快速幂// 矩阵乘法#define N 100int c[][N]; int res[N][N]// a b 都为方阵并且 是 n void multi_matrix(int a[][N],int b[][N],int n)&#123; for(int i = 0;i&lt;n;++i)&#123; for(int j = 0;j&lt;n;++j)&#123; for(int k = 0;k&lt;n;++k)&#123; c[i][j] = a[i][k]*b[k][j]; &#125; &#125; &#125; for(int i = 0;i&lt;n;++i)&#123; for(int j = 0;j&lt;n;++j)&#123; a[i][j] = c[i][j]; &#125; &#125;&#125;// 矩阵快速幂void matrix_exponentiation_by_squaring(int a[][N],int n)&#123; // 初始化结果矩阵 memset(res,0,sizeof(res)); for(int i = 0;i&lt;n;++i)&#123; res[i][i] = 1; &#125; while(n)&#123; if(n&amp;1) multi(res,a,n); multi(a,a,n); n&gt;&gt;=1; &#125;&#125; 矩阵快速幂解决斐波那契数列问题 open 参考文章 (130条消息) 矩阵快速幂优化递推式 例：斐波那契数列_G_congratulation的博客-CSDN博客 关于矩阵快速幂计算斐波那契数列的基本思想就是：斐波那契数列可以写作一个矩阵乘积式子如下： [FibonaccinFibonaccin−1]=[1,11,0]×[Fibonaccin−1Fibonaccin−2]\\left[ \\begin{matrix} Fibonacci_{n}\\\\ Fibonacci_{n-1}\\\\ \\end{matrix} \\right] = \\left[ \\begin{matrix} 1,1\\\\ 1,0 \\end{matrix} \\right] \\times \\left[ \\begin{matrix} Fibonacci_{n-1}\\\\ Fibonacci_{n-2}\\\\ \\end{matrix} \\right] [Fibonaccin​Fibonaccin−1​​]=[1,11,0​]×[Fibonaccin−1​Fibonaccin−2​​] 根据这个公式推导下去 求一个$$Fibonacci_{n}=A^{n-2}\\times Fib_{init} \\ \\ (n\\ge3)$$ 就是这样的公式 不难得出对应的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;// 矩阵快速幂求解斐波那契数列第n项问题const int M = 2; // 定义矩阵的长宽 const int N = 2;const int C = 1000001;struct Matrix&#123; long long a[M][N]; Matrix()&#123; memset(a,0,sizeof(a)); &#125; Matrix operator * (const Matrix b)&#123; Matrix ans; for(int i = 0;i&lt;M;++i) for(int j = 0;j&lt;N;++j) for(int k = 0;k&lt;N;++k) ans.a[i][j] += (a[i][k]*b.a[k][j]); return ans; &#125; void operator = (const Matrix b)&#123; for(int i = 0;i&lt;M;++i) for(int j = 0;j&lt;N;++j) a[i][j] = b.a[i][j]; &#125; &#125;; int exponentiation_by_squaring(int x)&#123; /* [1,1] [1] [1,0]的 n-2次方 最后乘以[1] */ Matrix ans,trans; ans.a[0][0] = 1; ans.a[1][0] = 1; trans.a[0][0] = trans.a[0][1] = trans.a[1][0] = 1; while(x)&#123; if(x&amp;1)ans = trans*ans; trans = trans*trans; x &gt;&gt;= 1; &#125; for(int i = 0;i&lt;M;++i) for(int j = 0;j&lt;N;++j) cout&lt;&lt;&quot;i: &quot;&lt;&lt;i&lt;&lt;&quot; j: &quot;&lt;&lt;j&lt;&lt;&quot; ans: &quot;&lt;&lt;ans.a[i][j]&lt;&lt;endl; return ans.a[1][0];&#125;int main()&#123; int n; while(1)&#123; cin&gt;&gt;n; cout&lt;&lt;exponentiation_by_squaring(n-1)&lt;&lt;endl; &#125; return 0;&#125; 将上面的代码稍稍改动一下就是POJ 3070 题的AC代码了 502 Bad Gateway (poj.org) 3150 – Cellular Automaton (poj.org) 英文能力有待提高啊 哭… TODO [x] 关于矩阵快速幂的拓展 [x] POJ 3070 [x] poj 3150 [ ] 关于矩阵乘积更快的算法的学习 [ ] POJ 3150 循环矩阵 [x] 矩阵快速幂解决斐波那契数列","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/categories/PAT/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://ninoneumann.cn/tags/algorithm/"},{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/tags/PAT/"}]},{"title":"线性代数错题","slug":"线性代数错题","date":"2022-04-19T08:03:29.000Z","updated":"2022-04-21T09:07:20.733Z","comments":true,"path":"2022/04/19/线性代数错题/","link":"","permalink":"https://ninoneumann.cn/2022/04/19/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E9%94%99%E9%A2%98/","excerpt":"","text":"线代错题 基础题 ∣1a0001a0001aa001∣=?\\left| \\begin{matrix} 1 &amp; a &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; a &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; a \\\\ a &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{matrix} \\right| =? ∣∣​100a​a100​0a10​00a1​∣∣​=? 设A,B皆为矩阵,且∣A∣=2,∣B∣=−3,则∣−ATB−1∣=?设A,B皆为矩阵,且\\lvert A \\rvert = 2,\\lvert B \\rvert = -3,则\\lvert -A^{T}B^{-1} \\rvert=? 设A,B皆为矩阵,且∣A∣=2,∣B∣=−3,则∣−ATB−1∣=? tips: 问题2注意 矩阵的负数 -A 这个（有负系数的矩阵的行列式的计算！！）","categories":[{"name":"数学","slug":"数学","permalink":"https://ninoneumann.cn/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://ninoneumann.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"错题","slug":"错题","permalink":"https://ninoneumann.cn/tags/%E9%94%99%E9%A2%98/"}]},{"title":"LinearAlgebra-Skill-points","slug":"LinearAlgebra-Skill-points","date":"2022-04-19T03:28:11.000Z","updated":"2022-06-17T08:50:20.490Z","comments":true,"path":"2022/04/19/LinearAlgebra-Skill-points/","link":"","permalink":"https://ninoneumann.cn/2022/04/19/LinearAlgebra-Skill-points/","excerpt":"","text":"更新时间线 学好线代很重要2022-6-17相似对角矩阵设定一下接下来还有什么要过一下行列式的意义添加一些行列式可逆的证明秩的性质 AB=O =&gt; rank(A)+rank(B)&lt;=2022-6-16求解向量组的极大线性无关组如果求方程组的解中遇到了无关的变量怎么办矩阵的特征值和特征向量2022-6-15哈密顿凯莱定理求解方阵的n次方两个向量组等价和矩阵等价之间的区别2022-6-11解方程组2022-5-24更新线性相关部分更新一些有关向量组线性相关的“断言”2022-4-24更新矩阵部分的一些内容更新 行列式 转置 求逆 伴随之间的运算规则（一定要牢记！）添加初等变换矩阵的一些变换操作。2022-4-19更新行列式部分的一些内容 Linear-Algebra Skill points 行列式 行列式的性质 经过转置 行列式的值不变 + 推导 如果出现某一行或者某一列的元素都为0 则行列式就是0 如果某一行是由加法构成那么可以拆开行列式 变为两个行列式的 加法或者减法（其余的行/列不变） 倍乘性质 可以提取公因子 k 倍加性质 不变的 如果存在两行/列及以上的 对应成比例 则行列式为0 任意两行/列互换 行列式的正负改变 两个矩阵的乘积的行列式=行列式的乘积 ∣AB∣=∣A∣∣B∣\\lvert AB \\rvert = \\lvert A \\rvert\\lvert B \\rvert ∣AB∣=∣A∣∣B∣ 行列式D的某一行（列）的元素与玲一行（列）对应元素的代数余子式乘积之和为0 引伸 克罗克内函数∑k=1naikAjk=δij⋅Dδij={1,i=j0,i≠j\\sum_{k=1}^{n}a_{ik}A_{jk}=\\delta_{ij}\\cdot D\\\\ \\delta_{ij}= \\begin{cases} 1, &amp; i=j \\\\ 0, &amp; i\\ne j \\end{cases} k=1∑n​aik​Ajk​=δij​⋅Dδij​={1,0,​i=ji=j​ 关于复合矩阵的行列式求解。 行列式的展开定理 代数余子式 深入理解余子式和代数余子式。 用展开定理和行列式的性质来化简行列式的并计算行列式 抽象 行列式 具象 行列式 一些具体的行列式的形式：记住 可以快速计算 直接展开 （简单的送分题） 行列式的意义 [6.17日更新] (3 封私信 / 22 条消息) 行列式的意义是什么？ - 知乎 (zhihu.com) 行列式等于它的各个列对应的向量张成的平行2n面体的体积，这是因为行列式是一个交替多重线性形式，而我们通常理解的欧式空间中的体积也是这样一个函数（单位立方体体积为1，沿某条边扩大c倍体积就扩大c倍，交换两条边以后体积反号——这一条是补充定义的，我们认为体积是有向体积，其数值表示体积大小，正负号表示各条边的排列顺序或坐标轴手性），而满足归一性、多线性、反对称性的函数是唯一的，所以行列式的直观理解就是欧式空间中的有向体积。 用矩阵与线性变换的同构来解释也很好理解，**行列式就是矩阵对应的线性变换对空间的拉伸程度的度量，或者说物体经过变换前后的体积比。**特别地，如果矩阵不是满秩的，意味着一个n维的空间变换后被压扁了，变成了其中的一个n-1维的超平面甚至是维度更低的超直线，所以原来空间中的体积元在变换后体积为0，此时行列式也是0。多元函数积分作变量代换后要乘一个Jacobi行列式就是这个道理，表示变换前后的微元体积比。 行列式 是一个由这些向量组成的体的有向体积 遇到的一些抽象行列式可逆与否的证明 矩阵 矩阵加法的一些知识点 ∣A+B∣≠∣A∣+∣B∣(A+B)T=?(A+B)−1=?(A+B)∗=?|A+B|\\neq|A|+|B|\\\\ (A+B)^{T} = ?\\\\ (A+B)^{-1} = ?\\\\ (A+B)^{*} = ?\\\\ ∣A+B∣=∣A∣+∣B∣(A+B)T=?(A+B)−1=?(A+B)∗=? 几个容易弄错的点： ∣kA∣=kn∣A∣≠k∣A∣(n⩾2,k≠0,1)∣A+B∣⇏∣A∣+∣B∣A≠O⇏∣A∣≠OA≠B⇏∣A∣≠∣B∣|k \\boldsymbol{A}|=k^{n}|\\boldsymbol{A}| \\neq k|\\boldsymbol{A}|(n \\geqslant 2, k \\neq 0,1)\\\\ |\\boldsymbol{A}+\\boldsymbol{B}| \\nRightarrow |\\boldsymbol{A}|+|\\boldsymbol{B}|\\\\ \\boldsymbol{A} \\neq \\boldsymbol{O} \\nRightarrow |\\boldsymbol{A}| \\neq \\boldsymbol{O}\\\\ \\boldsymbol{A} \\neq \\boldsymbol{B} \\nRightarrow |\\boldsymbol{A}| \\neq|\\boldsymbol{B}| ∣kA∣=kn∣A∣=k∣A∣(n⩾2,k=0,1)∣A+B∣⇏∣A∣+∣B∣A=O⇏∣A∣=OA=B⇏∣A∣=∣B∣ 矩阵乘法运算 求某一个给定的 具象的矩阵的n次方（找运算规律 数学归纳） 例如： A=[1−1−1−1−11−1−1−1−11−1−1−1−11]求An=A=\\left[\\begin{array}{cccc} 1 &amp; -1 &amp; -1 &amp; -1 \\\\ -1 &amp; 1 &amp; -1 &amp; -1 \\\\ -1 &amp; -1 &amp; 1 &amp; -1 \\\\ -1 &amp; -1 &amp; -1 &amp; 1 \\end{array}\\right] 求 A^{n}= A=⎣⎡​1−1−1−1​−11−1−1​−1−11−1​−1−1−11​⎦⎤​求An= 标准正交基 施密特标准正交化 转置 行列式 逆 基本的运算律： 数乘、加法、乘法 下面涉及到的矩阵A 都是n阶方阵、并且默认A 是可逆矩阵 1、套娃运算{∣∣A∣∣=∣A∣(A−1)−1=A(AT)T=A(A∗)∗=∣A∣n−2A2、数乘运算律{∣kA∣=kn∣A∣(kA)T=kAT(kA)−1=1kA−1(kA)∗=kn−1A∗3、穿脱{∣AB∣=∣A∣∣B∣=∣B∣∣A∣(AB)T=BTAT(AB)−1=B−1A−1(AB)∗=B∗A∗4、行列式运算{∣AT∣=∣A∣∣A−1∣=∣A∣−1∣A∗∣=∣A∣n−15、混合运算{(AT)−1=(A−1)T(AT)∗=(A∗)T(A∗)−1=(A−1)∗ 这三个运算都可以交换6、加法运算{∣A+B∣≠∣A∣+∣B∣(A+B)T=AT+BT(A+B)−1≠A−1+B−1(A+B)∗≠A∗+B∗1、套娃运算 \\begin{cases} \\big||A|\\big|=|A|\\\\ (A^{-1})^{-1}= A\\\\ (A^{T})^{T} = A\\\\ (A^{*})^{*} = |A|^{n-2}A\\\\ \\end{cases}\\\\ 2、数乘运算律 \\begin{cases} |kA| = k^{n}|A|\\\\ (kA)^{T} = kA^{T}\\\\ (kA)^{-1} = \\frac{1}{k}A^{-1}\\\\ (kA)^{*} = k^{n-1}A^{*}\\\\ \\end{cases}\\\\ 3、穿脱 \\begin{cases} |AB| = |A||B| = |B||A|\\\\ (AB)^{T} = B^{T}A^{T}\\\\ (AB)^{-1} = B^{-1}A^{-1}\\\\ (AB)^{*} = B^{*}A^{*}\\\\ \\end{cases}\\\\ 4、行列式运算 \\begin{cases} |A^{T}| = |A| \\\\ |A^{-1}| = |A|^{-1} \\\\ |A^{*}| = |A|^{n-1} \\\\ \\end{cases}\\\\ 5、混合运算 \\begin{cases} (A^{T})^{-1} = (A^{-1})^{T}\\\\ (A^{T})^{*} = (A^{*})^{T}\\\\ (A^{*})^{-1} = (A^{-1})^{*}\\\\ \\end{cases} \\ 这三个运算都可以交换\\\\ 6、加法运算 \\begin{cases} |A+B| \\neq |A|+|B| \\\\ (A+B)^{T} = A^{T}+B^{T} \\\\ (A+B)^{-1} \\neq A^{-1}+B^{-1} \\\\ (A+B)^{*} \\neq A^{*}+B^{*} \\\\ \\end{cases}\\\\ 1、套娃运算⎩⎨⎧​∣∣​∣A∣∣∣​=∣A∣(A−1)−1=A(AT)T=A(A∗)∗=∣A∣n−2A​2、数乘运算律⎩⎨⎧​∣kA∣=kn∣A∣(kA)T=kAT(kA)−1=k1​A−1(kA)∗=kn−1A∗​3、穿脱⎩⎨⎧​∣AB∣=∣A∣∣B∣=∣B∣∣A∣(AB)T=BTAT(AB)−1=B−1A−1(AB)∗=B∗A∗​4、行列式运算⎩⎨⎧​∣AT∣=∣A∣∣A−1∣=∣A∣−1∣A∗∣=∣A∣n−1​5、混合运算⎩⎨⎧​(AT)−1=(A−1)T(AT)∗=(A∗)T(A∗)−1=(A−1)∗​ 这三个运算都可以交换6、加法运算⎩⎨⎧​∣A+B∣=∣A∣+∣B∣(A+B)T=AT+BT(A+B)−1=A−1+B−1(A+B)∗=A∗+B∗​ 5公式组中的证明需要多看看【或者我添加进笔记里面】 求逆矩阵的方法 用伴随矩阵求逆矩阵 使用初等矩阵求逆矩阵 ​ 将矩阵分解为若干个初等变换矩阵的乘积。 ​ 分块阵求逆矩阵 矩阵初等变换 1、倍乘2、倍加3、交换1、倍乘1、倍乘\\\\ 2、倍加\\\\ 3、交换\\\\ 1、倍乘\\\\ 1、倍乘2、倍加3、交换1、倍乘 矩阵等价 A矩阵经过一些列的行变换和列变换变为B 充要条件 A 矩阵的秩=B矩阵的秩 6.15 补充： 两个矩阵等价可以表示为矩阵A(或者矩阵B)可以由初等变换变换为矩阵B(或者矩阵A) A=PBQA = PBQ A=PBQ 向量组等价 有（列）向量组$$[\\beta_{1},\\beta_{2},\\beta_{3},……\\beta_{s}]$$和（列）向量组$$[\\alpha_{1},\\alpha_{2},\\alpha_{3},……\\alpha_{s}]$$可以相互表示 则两个向量组等价！ 其充要条件是$$r(A)=r(B)=r([A,B])$$ 关于两个向量组之间互相表示的问题 假设有线性无关的向量组$$A = [\\alpha_{1},\\alpha_{2},\\alpha_{3},……\\alpha_{s}]$$（A中的所有列向量线性无关） 另有向量组$$B = [\\beta_{1},\\beta_{2},\\beta_{3},……\\beta_{s}]$$ 且 $$B = AC C是一个系数矩阵$$（表明了B 可以由A 表示） 则== $$rank(B) = rank©$$ 证明 判断矩阵的对称性 记得使用转置的一些性质 给定一个有关矩阵的方程让你确定某个未知的矩阵 有方程 AX=A+2X求X=?且A=某一个确定的矩阵有方程 \\ \\ AX = A+2X \\\\ 求X=? 且A=某一个确定的矩阵 有方程 AX=A+2X求X=?且A=某一个确定的矩阵 使用增广矩阵的求解方法将X矩阵的确定值求解出来当然前提是A可逆 向量组线性相关 若α1,α2,α3,α4......αs线性相关，并且αs不能被α1,α2,α3,α4......αs−1表出，则α1,α2,α3,α4......αs−1线性相关若\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}......\\alpha_{s}线性相关，并且\\alpha_{s}不能被\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}......\\alpha_{s-1}表出，则\\\\ \\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}......\\alpha_{s-1}线性相关 若α1​,α2​,α3​,α4​......αs​线性相关，并且αs​不能被α1​,α2​,α3​,α4​......αs−1​表出，则α1​,α2​,α3​,α4​......αs−1​线性相关 当αs\\alpha_{s}αs​不能为其余向量组成的向量组表出的时候就证明了αs\\alpha_{s}αs​是个多余向量其一定不参与其余向量的表出。 多余向量不增加秩的个数 判定向量组线性相关的七个定理 张宇线代基础第三讲 定理一9:10 定理二38:54 定理三35:00 定理四1:15:30 定理五 1:26:58 6 1:28:30 7 1:29:33 如何找一个矩阵的极大无关组 求出极大无关组之后其余的向量都可以由极大无关组表出 求表出方法 6.16 补充： 首先将给定的向量组矩阵化，接着使用初等行变换对矩阵进行阶梯化，最后找极大线性无关组对应的向量组中的列向量就ok了。 求方程组的解 1、分清楚 齐次方程组 非齐次方程组 2、对于具体的问题使用具体的方法 求方程组的解中遇到了无关变量 假设有AX=0这个齐次线性方程组 A=[1002001−3]A = \\begin{bmatrix} 1&amp;0&amp;0&amp;2\\\\ 0&amp;0&amp;1&amp;-3\\\\ \\end{bmatrix} A=[10​00​01​2−3​] 可以很容易发现$$x_{2}$$是一个系数为0 的东西并且系数矩阵的秩=2故有关$$x_{2}$$的基础解系的向量为$$[0,1,0,0]^{T}$$…… 你得注意判断方程组的基础解系中含有几个线性无关向量的依据是什么！！！ 方程组同解问题 1、两个方程组同解的充要条件 2、两个方程组同解的相关非充要条件 ![[Pasted image 20220612192018.png]] 感觉张宇真的很喜欢出同解的这个部分 使用哈密顿凯莱定理求解方阵的n次方 聊聊凯莱-哈密顿(Cayley-Hamilton)定理 - 知乎 (zhihu.com) 需要了解 特征方程和特征值 假设：A的矩阵为：[344−3]那么哈密顿凯莱定理是这么描述的f(λ)=∣λE−A∣ 那么显然f(A)=0 因为∣AE−A∣=0那么∣λE−A∣=∣λ−3−4−4λ+3∣=λ2−25故A2−25E=0……(下面就很明显了)假设：A 的矩阵为： \\begin{bmatrix} 3&amp;4\\\\ 4&amp;-3\\\\ \\end{bmatrix} 那么 哈密顿凯莱定理是这么描述的\\\\ f(\\lambda)=|\\lambda E-A| \\ 那么显然 f(A)=0 \\ 因为 |AE-A| = 0 \\\\ 那么|\\lambda E-A| = \\begin{vmatrix} \\lambda -3 &amp; -4\\\\ -4&amp; \\lambda +3\\\\ \\end{vmatrix} =\\lambda^{2}-25 \\\\ 故 A^{2}-25E=0 ……(下面就很明显了) 假设：A的矩阵为：[34​4−3​]那么哈密顿凯莱定理是这么描述的f(λ)=∣λE−A∣ 那么显然f(A)=0 因为∣AE−A∣=0那么∣λE−A∣=∣∣​λ−3−4​−4λ+3​∣∣​=λ2−25故A2−25E=0……(下面就很明显了) 对矩阵求n次方的最常见做法是使用对角化。 waiting for upgrading… 矩阵的特征值和特征向量 线性代数精华——矩阵的特征值与特征向量 - 知乎 (zhihu.com) 【科普】如何正确理解特征值与特征向量 - 知乎 (zhihu.com) 推荐上面的知乎文章 矩阵的特征值的定义: 如果存在Ax=λx 那么值λ为特征值 向量x 为特征向量 几何意义1 我们都知道，对于一个n维的向量x来说，如果我们给他乘上一个n阶的方阵A，得到Ax。从几何角度来说，是对向量x进行了一个线性变换。变换之后得到的向量y和原向量x的方向和长度都发生了改变。但是，对于一个特定的矩阵A来说，总存在一些特定方向的向量x，使得Ax和x的方向没有发生变化，只是长度发生了变化。我们令这个长度发生的变化当做是系数,那么对于这样的向量就称为是矩阵A的特征向量 几何意义2 如果把矩阵看作是位移，那么特征值 = 位移的速度，特征向量 = 位移的方向。 特征向量在一个矩阵的作用下作伸缩运动，伸缩的幅度由特征值确定（注意观察定义式） 特征值和特征向量的性质 几个问题: Q：对于每一个确定的矩阵A（非0矩阵） 一定存在至少一个特征值和特征向量？ A： con：特征值和特征向量的概念对应的是方阵 非方阵暂时我不想去考虑了 相似对角矩阵 理解矩阵得相似对角化 - 知乎 (zhihu.com) 找特征值 用特征值排列成对角矩阵 TODO [ ] 关于复合矩阵行列式的求解 [ ] 矩阵的相似对角化 [ ] 矩阵的特征值特征向量的更进一步 [ ] 矩阵的合同 [ ] 矩阵的二次型 [ ] 矩阵的正定 [ ] 引用标签好像不能用了 去看看 [ ]","categories":[{"name":"数学","slug":"数学","permalink":"https://ninoneumann.cn/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://ninoneumann.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"复习","slug":"复习","permalink":"https://ninoneumann.cn/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"技能点","slug":"技能点","permalink":"https://ninoneumann.cn/tags/%E6%8A%80%E8%83%BD%E7%82%B9/"}]},{"title":"LinearAlgebra-考研","slug":"LinearAlgebra-考研","date":"2022-04-19T03:11:10.000Z","updated":"2022-05-26T04:24:53.369Z","comments":true,"path":"2022/04/19/LinearAlgebra-考研/","link":"","permalink":"https://ninoneumann.cn/2022/04/19/LinearAlgebra-%E8%80%83%E7%A0%94/","excerpt":"","text":"更新日志 2022-4-23更新了矩阵部分2022-4-21更新了行列式部分 线性代数 Linear-Algebra 行列式 行列式的定义 二阶行列式的计算 二维向量 》几何层面是这两个向量的平行四边形的面积 三阶行列式的计算 三个向量组成的 平行六面体的体积！！ n阶行列式的定义：（用行列式的定义计算是一件不可取的事情） 行列式的性质 行列互换值不变 平行四边形 验证 行列地位等价 某一行 或某一列为0 则全为0 某一行或者某一列 有公因子 则 公因子可以提出来 倍乘性质 当一个二阶（也就是在平面空间内） 如果两个向量等比例 那么在空间上的表现是两个共线的向量 》面积=0；如果放在三阶 也就是 三维空间内呢？ 其中有两个向量共线 体积=0 但是有面积。 初等变换 性质 3 5 7 行列式的逆序数定义 画线法 适用二阶三阶 行列式展开定理 余子式 代数余子式 行列式的展开定理： 几个重要的行列式 主对角线 乘积为结果： 上下三角行列式 主对角线行列式 副对角线 乘积为结果： 左上三角行列式 右下三角行列式 副对角线行列式 拉普拉斯展开式（又一种行列式的展开形式） 必须是方阵 范德蒙行列式 具体型行列式的计算 直接展开 爪型行列式的四种形式 异爪型 具象的爪型行列式基本计算思想是用斜爪消去平爪。 行和相等 / 列和相等 拉普拉斯展开式 范德蒙行列式 递推法: 在递推中需要特别注意 三角行列式！！！！ 行列式也可看做一个函数 当特殊情况下行列式是一个数值 具体题型行列式的计算例题： 逆序数定义展开 代数余子式定义展开 三对角线异爪型行列式 需要使用代数余子式展开+递推 拉普拉斯展开式 范德蒙行列式题 递推法的例题： 将所有的列加到第一列上 （简单的做法！） 抽象型行列式的计算 依照性质进行化简计算。 余子式和代数余子式 可以加深理解的一个重点： 克罗克内函数的理解 关于性质行列式D的某一行（列）的元素与玲一行（列）对应元素的代数余子式乘积之和为0 需要理解的是给出任意的 Aij的组合加法A_{ij}的组合加法Aij​的组合加法 需要反推导出对应的行列式的样子：例如 对于行列式∣A∣=[1,23,4]求∑k=12A2k则根据上面的定理推导出需要求的行列式为[1,21,1]对于行列式 \\lvert A\\rvert= \\left[ \\begin{matrix} 1,&amp; 2\\\\ 3,&amp; 4 \\end{matrix} \\right]\\\\ 求 \\sum_{k=1}^{2}A_{2k} 则根据上面的定理推导出需要求的行列式为 \\left[ \\begin{matrix} 1,&amp; 2\\\\ 1,&amp; 1 \\end{matrix} \\right]\\\\ 对于行列式∣A∣=[1,3,​24​]求k=1∑2​A2k​则根据上面的定理推导出需要求的行列式为[1,1,​21​] 矩阵 矩阵的本质 行列向量的拼接 数表 矩阵的行列向量之间存在某种关系–这种关系反映了矩阵的本质——矩阵的秩 n 阶子式 给出的m阶矩阵任意挑出n行和n列 将交叉元素按照原顺序排列所得到的行列式 叫做n阶子式 矩阵的定义 矩阵的基本运算 矩阵相等 矩阵加法 数乘矩阵 矩阵的每个元素都要乘以该数 矩阵的乘法 $$m\\times n \\ n \\times k$$ 矩阵乘法的运算律 ==两个矩阵一般不能满足交换律== 当题目涉及矩阵之间的乘积交换的时候请务必小心！！ 两个0矩阵的乘积可以是0矩阵 AB=O⇏A≠O or B≠O推论:AB=AC，A≠O⇏B=CAB = \\bold{O} \\nRightarrow A \\neq \\bold{O} \\ or \\ B \\neq \\bold{O} \\\\ 推论:\\\\ AB=AC，A\\neq \\bold{O} \\nRightarrow B=C AB=O⇏A=O or B=O推论:AB=AC，A=O⇏B=C 矩阵的转置 转置的相关运算律 向量内积与正交 标准正交向量组 规范正交基 施密特标准正交化 正交化 标准化 矩阵的幂 方阵乘积的行列式 矩阵的逆 可逆的充要条件： ∣A∣≠0 则A可逆，其实也就是A满秩|A|\\neq0 \\ 则 A 可逆，其实也就是A 满秩 ∣A∣=0 则A可逆，其实也就是A满秩 逆矩阵的条件： 求逆矩阵的方法 方法一 方法二 方法三 伴随矩阵 这里可以适当联系克罗克内函数来多思考一些问题。 伴随矩阵的性质与重要公式 矩阵的伴随的伴随！！！推到过程很重要 初等变换与初等矩阵 初等变换： 初等矩阵： 可逆矩阵一定可以通过有限次的初等变换变换为同阶的单位矩阵E 使用初等矩阵求矩阵的逆 tips: 这个对具体矩阵求解其逆矩阵的方法之一。 分块阵如何求逆： 矩阵方程 矩阵的秩与等价矩阵 矩阵秩的定义： 矩阵中最高阶非零子式的阶数 ==秩的本质是组成该矩阵的线性无关的向量个数== 充要条件一 满秩矩阵的行列式不为0 解方程组 表示性问题 非齐次 相关性问题 齐次 齐次方程组 列满秩 非齐次方程组","categories":[{"name":"数学","slug":"数学","permalink":"https://ninoneumann.cn/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://ninoneumann.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"复习","slug":"复习","permalink":"https://ninoneumann.cn/tags/%E5%A4%8D%E4%B9%A0/"}]},{"title":"单词-4.19","slug":"单词-4-19","date":"2022-04-19T02:50:55.000Z","updated":"2022-04-26T08:29:21.677Z","comments":true,"path":"2022/04/19/单词-4-19/","link":"","permalink":"https://ninoneumann.cn/2022/04/19/%E5%8D%95%E8%AF%8D-4-19/","excerpt":"","text":"4.19 今日份单词 单词 dean n 院长，系主任 the dean of the math department adverse adj 不利的，有害的 adverse condition 不利的条件 auxiliary adj 辅助的 备用的 auxiliary nurse 助理护士 slender adj 苗条的 纤细的 she is tall and slender hisfinger is slender stern adj 严厉的，苛刻的 a stern warning appraisal n 评价 鉴定，（对员工的）考核 a property appraisal trim vt 修剪 trim your hair augment vt 增大 加强。 intimidate vt 恐吓，威胁 slot n 狭口，投币口 vi vt 投币，投放，被塞进 coin slot （n）投币口 be slotted together 被拼装到一起 encyclopedia n 百科全书 renovate vt 修复，翻新，改造 synthesis n 综合的 合成 a synthesis of sth setback n 挫折，阻碍。 a major setback. henceforth adv 从今以后，从现在起 Henceforth, you will not contact me invariably adv 总是，始终如一地 invariably correct colonel n 上校 foul adj 肮脏恶臭的， 令人不愉快的 foul air foul mood 糟糕的心情。 weave vt vi 编织 weave a cloth vt 编造 he weaved the story. propel vt 推动 Extraodinary men propel us forward. redundant adj 多余的 累赘的 redundant information veteran n 有经验的人，老手 退伍军人 a veteran actor erosion n 侵蚀，逐渐削弱 parasite n 寄生虫 brook n 小溪，小河 a babbling brook vt 允许，容忍 babble vi 潺潺作响 preside vi 主持，负责 preside over sth i need to preside over the meeting. qualitative adj 定性的，质量的没兴致的 a qualitative analysis 定性分析. napkin n 餐巾 motive n 动机缘由 a possible motive retrospect n 回顾，回想 in retrospect conversion n 转变，改变 conversion from A to B inhabitant n 居民 pendulum n 钟摆 the pendulum on the clock overwhelming adj 无法抗拒的 压倒性的。 the grief is overwhelming drastic adj 严厉的，极端的，变化巨大的 a drastic change 一场巨变。 a drastic solution 一个极端的方法 overpass n 高架桥，跨线桥，立交桥 a highway overpass 公路立交桥 pierce vt vi 刺入 pierce your ear 打耳洞 pierce through sth 刺入某物刺穿某物。 malignant adj 恶性的, 恶毒的 a malignant tumor compatible adj 兼容的， 可以共存的， 合得来的。 be compatible with 与……兼容。 notorious adj 臭名昭著的，声名狼藉的 a notorious liar be notorious for oath n 誓言 宣誓 take an oath you all taken an oath to uphold the law. oven n 烤箱 deck n 甲板 on deck 在甲板上。 uproar n 喧嚣，吵闹 be in an uproar 吵闹 texture n 质感，口感 a rough texture 粗糙的质感（手感） ==articulate== vt 清楚地表达 articulate a reason shutter n 百叶窗，快门 installment n 一期（故事，分期付款） sue vi vt sue sb for sth secondary adj 中学的 次要的 继发的 corrode vt vi 使腐蚀 侵蚀 corrode metal 腐蚀金属 refute vt 反驳 refute an argument 反驳论点。 optimum adj 最佳的 make optimum use of 充分利用。 meditate vi 冥想 沉思 mediate on our future vt 策划，计划 meditate a dance。 exemplify vt 是…… 的典范 exemplify a virtue crude adj 粗糙的 rough 天然的 n 原油 石油 a barrel of crude 一桶原油 orderly gramme n 克 reproach n 责备 责备的话语 a stern reproach vt 责备 reproach sharply knob n 旋转 turn a knob 旋转旋钮 obstruction n 阻挡，阻碍 pronoum n 代词，代名词 innumerable adj 大量的 innumerable lives intuition n 直觉 直觉能力 follow your intuition pillar n 柱子，主心骨 punch vt 用拳击打 punch sb in (part of the body) he punched me in the face. haul vt 用力拖拽 haul car away 把车拖走。 zeal n 热情 zeal for / in sth my work hold no zeal. recur vi 再次发生 a recurring problem","categories":[{"name":"每日英语单词","slug":"每日英语单词","permalink":"https://ninoneumann.cn/categories/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"英语","slug":"英语","permalink":"https://ninoneumann.cn/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"单词","slug":"单词","permalink":"https://ninoneumann.cn/tags/%E5%8D%95%E8%AF%8D/"}]},{"title":"美化blog记录","slug":"美化blog记录","date":"2022-04-18T08:18:30.000Z","updated":"2022-04-21T15:22:15.215Z","comments":true,"path":"2022/04/18/美化blog记录/","link":"","permalink":"https://ninoneumann.cn/2022/04/18/%E7%BE%8E%E5%8C%96blog%E8%AE%B0%E5%BD%95/","excerpt":"","text":"blog 参考博客： 教程：基于Butterfly主题的分类磁铁 | 小冰博客 (zfe.space) Iconfont Inject | Akilarの糖果屋 内容布局重构 [x] 历史上的今天 [x] 美化底部 [x] 添加Github徽标 [x] 使用方法 Add Github Badge | Akilarの糖果屋 [x] Copyright-beautify [x] 使用方法 [x] Friend link subscription [x] 暂时没有效果 [x] 自定义样式魔改 [x] 一图流。 [x] title字体 [x] subtitle字体 [x] 鼠标指针美化 [x] 创建一个npm图床做鼠标的图床 使用github-action推送博客部署仓库至NPM | Akilarの糖果屋 [x] 站点动态title [x] 国家公祭日变灰 [x] 随机背景 [x] 彩色/渐变色网站名称. 主标题/副标题 [x] 外挂标签 [x] 使用方法 Butterfly主题美化日记 | Akilarの糖果屋 [x] gitcalendar [x] 自建api+部署 [x] 暂时还没效果 [x] 问题：不显示 [x] 是自建api搜索时候的用户名出问题了 [x] Swiper Bar [x] 使用方法？ [x] 测试 暂时没有显示 [x] 每页单独配置背景图 [x] 使用方法 [x] 个性化 [x] 首页磁贴 [x] 使用方法 [x] 生成tags [x] 生成categories [x] 生成links [x] 添加左侧时钟 [x] 侧边栏说说 使用方法 123456789101112131415161718192021222324252627282930313233343536# artitalk see https://artitalk.js.org/ # hexo-butterfly-artitalk-pro # see https://akilar.top/posts/f1004b1d/ artitalk: enable: card: true # 侧边栏开关 page: true #页面开关 # 侧栏相关配置项 priority: 5 #过滤器优先权 enable_page: all # 应用页面 layout: # 挂载容器类型 type: class name: sticky_layout index: 0 # 页面相关配置项 path: artitalk front_matter: title: 碎碎念 # 公共配置项 appId: *************************** appKey: **************************** exclude: - /artitalk/ - /posts/ #需要abbrlink插件支持 js: https://unpkg.zhimg.com/artitalk card_css: https://unpkg.zhimg.com/hexo-butterfly-artitalk-pro/lib/card.css card_visual_js: https://unpkg.zhimg.com/hexo-butterfly-artitalk-pro/lib/card_visual.js option: serverURL: https://********.api.lncldglobal.com #********替换成你的appID前八位 lang: zh pageSize: 1 color1: &#x27;#49b1f5&#x27; color2: &#x27;#00c4b6&#x27; atEmoji: &#123; &#x27;Mafumafu1&#x27;:&#x27;https://cdn.jsdelivr.net/gh/GamerNoTitle/ValineCDN@master/Mafumafu/199749454.png&#x27;, &#x27;Mafumafu2&#x27;:&#x27;https://cdn.jsdelivr.net/gh/GamerNoTitle/ValineCDN@master/Mafumafu/199749455.png&#x27;&#125; hexo-butterfly-artitalk-pro - npm (npmjs.com) [x] wowjs动画效果 [x] 使用方法 hexo-butterfly-wowjs - npm (npmjs.com) [x] 配置阿里图标库 [x] 引入时间轴图标 [x] 文章双栏 [x] 引入动画效果之后 时间轴不显示问题 [x] 是图标引入的问题. 关于magnet 磁铁中的cion来源： 12345678910111213magnet: enable: true priority: 1 enable_page: all type: categories devide: 2 display: - name: 专业课 display_name: CS必修课程 icon: 📚 - name: 不正经做事儿系列 display_name: 就瞎搞，不搞正事儿 icon: 🎮 magnet 中显示icon的符号可以在 https://www.emojiall.com/zh-hans/ 这个网站中找到。 [x] post 页面不显示行内数学公式？ 是hexo 的render 引擎的问题 需要进行一些语法修改 并且 行内内嵌公式也用双$ 做开头结尾 [x] 学一下 Akilarの糖果屋 的文章首部 日志 [x] 也就是添加文章中的可折叠内容 hexo-sliding-spoiler 美化+自定义 查看标签语法的应用 Tag Plugins Plus | Akilarの糖果屋 我觉的就这个标签语法 我得单开一个博客去说明。 [ ] 自动更新文章的修改时间？ TO DO [ ] 处理gifsicle报错问题 [ ] 个性化 [ ] wowjs动画效果 [ ] 侧边栏说说 [ ] 首页磁贴 [ ] 鼠标指针美化 [ ] 友链个性化（待定） [x] gitcalendar [ ] Swiper Bar","categories":[{"name":"不正经做事儿系列","slug":"不正经做事儿系列","permalink":"https://ninoneumann.cn/categories/%E4%B8%8D%E6%AD%A3%E7%BB%8F%E5%81%9A%E4%BA%8B%E5%84%BF%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"blog个性化","slug":"blog个性化","permalink":"https://ninoneumann.cn/tags/blog%E4%B8%AA%E6%80%A7%E5%8C%96/"}]},{"title":"计算机网络第一章","slug":"计算机网络第一章","date":"2022-04-14T08:19:51.000Z","updated":"2022-04-26T08:30:40.584Z","comments":true,"path":"2022/04/14/计算机网络第一章/","link":"","permalink":"https://ninoneumann.cn/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"计算机网络第一章 掌握基本概念 基本原理 基本方法 掌握计算机网络的体系结构、典型的网络协议；了解网络设备的组成和特点 进行网络分析 设计 以及 应用 理解 记忆 抓住 重点 计算机网络的体系概述 1、计算机网络的基本概念 是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统 2、计算机网络的功能 数据通信 资源共享 分布式处理 提高可靠性 （想想云中的RAID ） 3、 计算机网络的发展 第一阶段 ARPA网 第二阶段 三级网络结构 第三阶段 多层次ISP结构 4、一些名词： ISP internet service provider IP 池 ARPA 网 网络数据IP寻找过程: ISP 结构的理解： 树形模型： 计算机网络的组成 1、组成部分 软件、硬件、协议 2、工作方式 按照网络中主机的分布来看 分为 边缘部分 C/S B/S P2P 对等连接 peer to peer 核心部分 为边缘部分提供服务 3、功能组成 通信子网 实现数据通信 资源子网 实现资源共享 计算机网络的分类 按照分布范围 广域网 WAN (广域网技术) 交换技术 城域网 MAN 局域网 LAN （局域网技术） 广播技术 个人区域网 PAN 按使用着 公用网 专用网 按照交换技术 电路交换 报文交换 分组交换 按照拓扑结构 总线型 星型 环形 网状型 按照传输技术 广播式网络 点对点网络 （广域网 WAN） 使用分组存储转发 和 路由机制 标准化工作 标准分类 - 法定标准 OSI七层参考模型 - 事实标准 TCP/IP 标准化的过程 RFC（Request For Comments）—— 因特网标准的形式 RFC上升到英特网正式标准的四个阶段 草案 建议标准 草案标准 因特网标准 ISO 国际标准化组织 ITU 国际电信联盟 IEEE 国际电子电气工程师协会 IETF internet工程任务组 性能指标 速率 数据率、数据传输率、比特率 换算： 带宽 单位时间内从网络的一段到另一端的最高数据率 （最高传输速率） 吞吐量 单位时间内通过某个网络（通道、接口）的数据量 单位 b/s kb/s mb/s 时延 发送时延 发送时延=数据长度信道带宽(发送速率)发送时延=\\frac{数据长度}{信道带宽(发送速率)} 发送时延=信道带宽(发送速率)数据长度​ 传播时延 取决于电磁波速度和链路长度 传播时延=信道长度电磁波在信道上传播的速率传播时延=\\frac{信道长度}{电磁波在信道上传播的速率} 传播时延=电磁波在信道上传播的速率信道长度​ 排队时延 等待输出/输入链路可用 处理时延 检错和找出口 时延带宽积 时延带宽积=传播时延×带宽时延带宽积=传播时延\\times带宽 时延带宽积=传播时延×带宽 关于时延带宽积的一个形象的理解： 往返时延RTT （Round Trip Time） 从发送方发送数据开始，到发送方接收到接收方的确认总共经历的时延。 windows中在命令行窗口使用ping命令： RTT 包含的内容 往返传播时延 = 传播时延*2 末端处理时间 利用率 信道利用率 有数据通过的时间(有+无)数据通过的时间\\frac{有数据通过的时间}{(有+无)数据通过的时间} (有+无)数据通过的时间有数据通过的时间​ 网络利用率 网络中有很多信道！！ 网络利用率就是信道利用率的加权平均值 体系结构和参考模型 分层结构 名词： 实体 对等实体 协议 一系列的规则和约定 只有对等实体之间才会存在协议 接口 服务 下级为上级提供服务 1、每一层相互独立 2、每一层之间的界面自然清晰 相互的交流尽可能少 3、结构上可以分开 每一层使用自己最适合的技术来实现 4、保持下层对上层的独立性 上层单向使用下层提供的服务 整个分层能够促进标准化工作 分层结构中数据的传输过程 SDU：服务数据单元 （service data unit） PCI：协议控制信息（Protocol Control Information） SDU+PCI = PDU：协议数据单元（Protocol Data Unit） 数据就这样从发送信息的最上层 向下一层层将数据打包 通过物理链路发送到接收方 接收方接受数据 向上一层层解包 最终获得数据 OSI 七层参考模型 七层参考模型的组成 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 上三层 == 资源子网 下三层 == 通信子网 应用层 所有能和用户交互产生网络流量的程序 典型的传输协议 FTP SMTP HTTP 表示层 功能 数据格式变换 对数据进行加密和解密码 数据的压缩和恢复 会话层 session 建立连接 像表示层的实体提供建立连接 并在连接上有序地传输数据 建立同步（SYN） 建立 管理 终止会话 使用校验点可以使得会话在通信实现的时候从校验点/同步点 继续恢复通信，实现数据同步 对应的协议 ADSP ASP 传输层 负责连个进程的通信，即端到端的通信 传输单位是报文段或者是用户数据报 功能： 可靠传输、不可靠传输 可靠传输 基于确认机制 流量控制 速度匹配 发送和接收的速度 差错控制 丢包的操作 复用分用 复用：多个进程可以同时使用传输层的服务 分用：传输层将收到的信息分发给对应的数据 对应的协议 TCP UDP 网络层 功能 路由选择 最佳路径选择 流量控制 差错控制 数据校验 拥塞控制 协议 IP 数据链路层 将网络层传下来的数据组装成帧 传输单位是帧 功能 成帧（定义帧的开始 和 帧的结束） 差错控制 帧错 位错 流量控制 访问控制 控制对信道的访问 对应的协议： SDLC 、HDLC 物理层 在物理媒体上传输数据 透明传输 功能： 定义接口特性 定义传输模式 单工 半双工 双工 定义传输速率 比特同步 比特编码 Rj45 802.3 TCP/IP 四层参考模型 TCP IP模型 应用层 传输层 网际层 网络接口层 OSI 参考模型和 TCP/IP参考模型的相同点和不同点 相同点 都分层 基于独立的协议栈概念 可以实现异构的网络互联 不同点 五层参考模型 五层参考模型的封装和解封装","categories":[{"name":"专业课","slug":"专业课","permalink":"https://ninoneumann.cn/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}],"tags":[{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://ninoneumann.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}],"categories":[{"name":"不正经做事儿系列","slug":"不正经做事儿系列","permalink":"https://ninoneumann.cn/categories/%E4%B8%8D%E6%AD%A3%E7%BB%8F%E5%81%9A%E4%BA%8B%E5%84%BF%E7%B3%BB%E5%88%97/"},{"name":"英语二","slug":"英语二","permalink":"https://ninoneumann.cn/categories/%E8%8B%B1%E8%AF%AD%E4%BA%8C/"},{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/categories/%E8%80%83%E7%A0%94/"},{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/categories/PAT/"},{"name":"专业课","slug":"专业课","permalink":"https://ninoneumann.cn/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"PAT刷题记录","slug":"PAT刷题记录","permalink":"https://ninoneumann.cn/categories/PAT%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"每日英语单词","slug":"每日英语单词","permalink":"https://ninoneumann.cn/categories/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"},{"name":"hexo魔改","slug":"hexo魔改","permalink":"https://ninoneumann.cn/categories/hexo%E9%AD%94%E6%94%B9/"},{"name":"数学","slug":"数学","permalink":"https://ninoneumann.cn/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Anki","slug":"Anki","permalink":"https://ninoneumann.cn/tags/Anki/"},{"name":"英语","slug":"英语","permalink":"https://ninoneumann.cn/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"考研","slug":"考研","permalink":"https://ninoneumann.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"编码规范","slug":"编码规范","permalink":"https://ninoneumann.cn/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"algorithm","slug":"algorithm","permalink":"https://ninoneumann.cn/tags/algorithm/"},{"name":"PAT","slug":"PAT","permalink":"https://ninoneumann.cn/tags/PAT/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://ninoneumann.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"专业课","slug":"专业课","permalink":"https://ninoneumann.cn/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"单词","slug":"单词","permalink":"https://ninoneumann.cn/tags/%E5%8D%95%E8%AF%8D/"},{"name":"AI","slug":"AI","permalink":"https://ninoneumann.cn/tags/AI/"},{"name":"CNN","slug":"CNN","permalink":"https://ninoneumann.cn/tags/CNN/"},{"name":"hexo","slug":"hexo","permalink":"https://ninoneumann.cn/tags/hexo/"},{"name":"博客魔改","slug":"博客魔改","permalink":"https://ninoneumann.cn/tags/%E5%8D%9A%E5%AE%A2%E9%AD%94%E6%94%B9/"},{"name":"伪代码","slug":"伪代码","permalink":"https://ninoneumann.cn/tags/%E4%BC%AA%E4%BB%A3%E7%A0%81/"},{"name":"编译原理","slug":"编译原理","permalink":"https://ninoneumann.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"程序设计","slug":"程序设计","permalink":"https://ninoneumann.cn/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"PAT-30-scores","slug":"PAT-30-scores","permalink":"https://ninoneumann.cn/tags/PAT-30-scores/"},{"name":"并查集","slug":"并查集","permalink":"https://ninoneumann.cn/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"PAT-20-scores","slug":"PAT-20-scores","permalink":"https://ninoneumann.cn/tags/PAT-20-scores/"},{"name":"技能点","slug":"技能点","permalink":"https://ninoneumann.cn/tags/%E6%8A%80%E8%83%BD%E7%82%B9/"},{"name":"高等数学","slug":"高等数学","permalink":"https://ninoneumann.cn/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"线性代数","slug":"线性代数","permalink":"https://ninoneumann.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"错题","slug":"错题","permalink":"https://ninoneumann.cn/tags/%E9%94%99%E9%A2%98/"},{"name":"复习","slug":"复习","permalink":"https://ninoneumann.cn/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"blog个性化","slug":"blog个性化","permalink":"https://ninoneumann.cn/tags/blog%E4%B8%AA%E6%80%A7%E5%8C%96/"}]}